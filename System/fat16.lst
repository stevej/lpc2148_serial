   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 18, 4
  11              		.file	"fat16.c"
  19              	.Ltext0:
  20              		.align	2
  22              	fat16_dir_entry_seek_callback:
  23              	.LFB5:
  24              		.file 1 "SYSTEM/fat16.c"
   1:SYSTEM/fat16.c **** /* This program is free software; you can redistribute it and/or modify
   2:SYSTEM/fat16.c ****  * it under the terms of the GNU General Public License version 2 as
   3:SYSTEM/fat16.c ****  * published by the Free Software Foundation.
   4:SYSTEM/fat16.c ****  */
   5:SYSTEM/fat16.c **** 
   6:SYSTEM/fat16.c **** #include <stdio.h>
   7:SYSTEM/fat16.c **** 
   8:SYSTEM/fat16.c **** //Debug
   9:SYSTEM/fat16.c **** #include "rprintf.h"
  10:SYSTEM/fat16.c **** 
  11:SYSTEM/fat16.c **** #include "partition.h"
  12:SYSTEM/fat16.c **** #include "fat16.h"
  13:SYSTEM/fat16.c **** #include "fat16_config.h"
  14:SYSTEM/fat16.c **** #include "sd_raw.h"
  15:SYSTEM/fat16.c **** 
  16:SYSTEM/fat16.c **** #include <stdlib.h>
  17:SYSTEM/fat16.c **** #include <string.h>
  18:SYSTEM/fat16.c **** 
  19:SYSTEM/fat16.c **** /**
  20:SYSTEM/fat16.c ****  * \addtogroup fat16 FAT16 support
  21:SYSTEM/fat16.c ****  *
  22:SYSTEM/fat16.c ****  * This module implements FAT16 read and write access.
  23:SYSTEM/fat16.c ****  *
  24:SYSTEM/fat16.c ****  * The following features are supported:
  25:SYSTEM/fat16.c ****  * - File names up to 31 characters long.
  26:SYSTEM/fat16.c ****  * - Unlimited depth of subdirectories.
  27:SYSTEM/fat16.c ****  * - Short 8.3 and long filenames.
  28:SYSTEM/fat16.c ****  * - Creating and deleting files.
  29:SYSTEM/fat16.c ****  * - Reading and writing from and to files.
  30:SYSTEM/fat16.c ****  * - File resizing.
  31:SYSTEM/fat16.c ****  * - File sizes of up to 4 gigabytes.
  32:SYSTEM/fat16.c ****  *
  33:SYSTEM/fat16.c ****  * @{
  34:SYSTEM/fat16.c ****  */
  35:SYSTEM/fat16.c **** /**
  36:SYSTEM/fat16.c ****  * \file
  37:SYSTEM/fat16.c ****  * FAT16 implementation.
  38:SYSTEM/fat16.c ****  *
  39:SYSTEM/fat16.c ****  * \author Roland Riegel
  40:SYSTEM/fat16.c ****  */
  41:SYSTEM/fat16.c **** 
  42:SYSTEM/fat16.c **** /**
  43:SYSTEM/fat16.c ****  * \addtogroup fat16_config FAT16 configuration
  44:SYSTEM/fat16.c ****  * Preprocessor defines to configure the FAT16 implementation.
  45:SYSTEM/fat16.c ****  */
  46:SYSTEM/fat16.c **** 
  47:SYSTEM/fat16.c **** /**
  48:SYSTEM/fat16.c ****  * \addtogroup fat16_fs FAT16 access
  49:SYSTEM/fat16.c ****  * Basic functions for handling a FAT16 filesystem.
  50:SYSTEM/fat16.c ****  */
  51:SYSTEM/fat16.c **** 
  52:SYSTEM/fat16.c **** /**
  53:SYSTEM/fat16.c ****  * \addtogroup fat16_file FAT16 file functions
  54:SYSTEM/fat16.c ****  * Functions for managing files.
  55:SYSTEM/fat16.c ****  */
  56:SYSTEM/fat16.c **** 
  57:SYSTEM/fat16.c **** /**
  58:SYSTEM/fat16.c ****  * \addtogroup fat16_dir FAT16 directory functions
  59:SYSTEM/fat16.c ****  * Functions for managing directories.
  60:SYSTEM/fat16.c ****  */
  61:SYSTEM/fat16.c **** 
  62:SYSTEM/fat16.c **** /**
  63:SYSTEM/fat16.c ****  * @}
  64:SYSTEM/fat16.c ****  */
  65:SYSTEM/fat16.c **** 
  66:SYSTEM/fat16.c **** #define FAT16_CLUSTER_FREE 0x0000
  67:SYSTEM/fat16.c **** #define FAT16_CLUSTER_RESERVED_MIN (uint16_t)0xfff0
  68:SYSTEM/fat16.c **** #define FAT16_CLUSTER_RESERVED_MAX (uint16_t)0xfff6
  69:SYSTEM/fat16.c **** #define FAT16_CLUSTER_BAD (uint16_t)0xfff7
  70:SYSTEM/fat16.c **** #define FAT16_CLUSTER_LAST_MIN (uint16_t)0xfff8
  71:SYSTEM/fat16.c **** #define FAT16_CLUSTER_LAST_MAX (uint16_t)0xffff
  72:SYSTEM/fat16.c **** 
  73:SYSTEM/fat16.c **** #define FAT16_DIRENTRY_DELETED 0xe5
  74:SYSTEM/fat16.c **** #define FAT16_DIRENTRY_LFNLAST (1 << 6)
  75:SYSTEM/fat16.c **** #define FAT16_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  76:SYSTEM/fat16.c **** 
  77:SYSTEM/fat16.c **** /* Each entry within the directory table has a size of 32 bytes
  78:SYSTEM/fat16.c ****  * and either contains a 8.3 DOS-style file name or a part of a
  79:SYSTEM/fat16.c ****  * long file name, which may consist of several directory table
  80:SYSTEM/fat16.c ****  * entries at once.
  81:SYSTEM/fat16.c ****  *
  82:SYSTEM/fat16.c ****  * multi-byte integer values are stored little-endian!
  83:SYSTEM/fat16.c ****  *
  84:SYSTEM/fat16.c ****  * 8.3 file name entry:
  85:SYSTEM/fat16.c ****  * ====================
  86:SYSTEM/fat16.c ****  * offset  length  description
  87:SYSTEM/fat16.c ****  *      0       8  name (space padded)
  88:SYSTEM/fat16.c ****  *      8       3  extension (space padded)
  89:SYSTEM/fat16.c ****  *     11       1  attributes (FAT16_ATTRIB_*)
  90:SYSTEM/fat16.c ****  
  91:SYSTEM/fat16.c ****  *     0x0E     2  Creation Time
  92:SYSTEM/fat16.c ****  *     0x10     2  Creation Date
  93:SYSTEM/fat16.c ****  
  94:SYSTEM/fat16.c ****  *
  95:SYSTEM/fat16.c ****  * long file name (lfn) entry ordering for a single file name:
  96:SYSTEM/fat16.c ****  * ===========================================================
  97:SYSTEM/fat16.c ****  * LFN entry n
  98:SYSTEM/fat16.c ****  *     ...
  99:SYSTEM/fat16.c ****  * LFN entry 2
 100:SYSTEM/fat16.c ****  * LFN entry 1
 101:SYSTEM/fat16.c ****  * 8.3 entry (see above)
 102:SYSTEM/fat16.c ****  *
 103:SYSTEM/fat16.c ****  * lfn entry:
 104:SYSTEM/fat16.c ****  * ==========
 105:SYSTEM/fat16.c ****  * offset  length  description
 106:SYSTEM/fat16.c ****  *      0       1  ordinal field
 107:SYSTEM/fat16.c ****  *      1       2  unicode character 1
 108:SYSTEM/fat16.c ****  *      3       3  unicode character 2
 109:SYSTEM/fat16.c ****  *      5       3  unicode character 3
 110:SYSTEM/fat16.c ****  *      7       3  unicode character 4
 111:SYSTEM/fat16.c ****  *      9       3  unicode character 5
 112:SYSTEM/fat16.c ****  *     11       1  attribute (always 0x0f)
 113:SYSTEM/fat16.c ****  *     12       1  type (reserved, always 0)
 114:SYSTEM/fat16.c ****  *     13       1  checksum
 115:SYSTEM/fat16.c ****  *     14       2  unicode character 6
 116:SYSTEM/fat16.c ****  *     16       2  unicode character 7
 117:SYSTEM/fat16.c ****  *     18       2  unicode character 8
 118:SYSTEM/fat16.c ****  *     20       2  unicode character 9
 119:SYSTEM/fat16.c ****  *     22       2  unicode character 10
 120:SYSTEM/fat16.c ****  *     24       2  unicode character 11
 121:SYSTEM/fat16.c ****  *     26       2  cluster (unused, always 0)
 122:SYSTEM/fat16.c ****  *     28       2  unicode character 12
 123:SYSTEM/fat16.c ****  *     30       2  unicode character 13
 124:SYSTEM/fat16.c ****  *
 125:SYSTEM/fat16.c ****  * The ordinal field contains a descending number, from n to 1.
 126:SYSTEM/fat16.c ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 127:SYSTEM/fat16.c ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 128:SYSTEM/fat16.c ****  */
 129:SYSTEM/fat16.c **** 
 130:SYSTEM/fat16.c **** struct fat16_header_struct
 131:SYSTEM/fat16.c **** {
 132:SYSTEM/fat16.c ****     uint32_t size;
 133:SYSTEM/fat16.c **** 
 134:SYSTEM/fat16.c ****     uint32_t fat_offset;
 135:SYSTEM/fat16.c ****     uint32_t fat_size;
 136:SYSTEM/fat16.c **** 
 137:SYSTEM/fat16.c ****     uint16_t sector_size;
 138:SYSTEM/fat16.c ****     uint16_t cluster_size;
 139:SYSTEM/fat16.c **** 
 140:SYSTEM/fat16.c ****     uint32_t root_dir_offset;
 141:SYSTEM/fat16.c **** 
 142:SYSTEM/fat16.c ****     uint32_t cluster_zero_offset;
 143:SYSTEM/fat16.c **** };
 144:SYSTEM/fat16.c **** 
 145:SYSTEM/fat16.c **** struct fat16_fs_struct
 146:SYSTEM/fat16.c **** {
 147:SYSTEM/fat16.c ****     struct partition_struct* partition;
 148:SYSTEM/fat16.c ****     struct fat16_header_struct header;
 149:SYSTEM/fat16.c **** };
 150:SYSTEM/fat16.c **** 
 151:SYSTEM/fat16.c **** struct fat16_file_struct
 152:SYSTEM/fat16.c **** {
 153:SYSTEM/fat16.c ****     struct fat16_fs_struct* fs;
 154:SYSTEM/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 155:SYSTEM/fat16.c ****     uint32_t pos;
 156:SYSTEM/fat16.c ****     uint16_t pos_cluster;
 157:SYSTEM/fat16.c **** };
 158:SYSTEM/fat16.c **** 
 159:SYSTEM/fat16.c **** struct fat16_dir_struct
 160:SYSTEM/fat16.c **** {
 161:SYSTEM/fat16.c ****     struct fat16_fs_struct* fs;
 162:SYSTEM/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 163:SYSTEM/fat16.c ****     uint16_t entry_next;
 164:SYSTEM/fat16.c **** };
 165:SYSTEM/fat16.c **** 
 166:SYSTEM/fat16.c **** struct fat16_read_callback_arg
 167:SYSTEM/fat16.c **** {
 168:SYSTEM/fat16.c ****     uint16_t entry_cur;
 169:SYSTEM/fat16.c ****     uint16_t entry_num;
 170:SYSTEM/fat16.c ****     uint32_t entry_offset;
 171:SYSTEM/fat16.c ****     uint8_t byte_count;
 172:SYSTEM/fat16.c **** };
 173:SYSTEM/fat16.c **** 
 174:SYSTEM/fat16.c **** struct fat16_usage_count_callback_arg
 175:SYSTEM/fat16.c **** {
 176:SYSTEM/fat16.c ****     uint16_t cluster_count;
 177:SYSTEM/fat16.c ****     uint8_t buffer_size;
 178:SYSTEM/fat16.c **** };
 179:SYSTEM/fat16.c **** 
 180:SYSTEM/fat16.c **** static uint8_t fat16_read_header(struct fat16_fs_struct* fs);
 181:SYSTEM/fat16.c **** static uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, stru
 182:SYSTEM/fat16.c **** static uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const
 183:SYSTEM/fat16.c **** static uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p);
 184:SYSTEM/fat16.c **** static uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p);
 185:SYSTEM/fat16.c **** static uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* r
 186:SYSTEM/fat16.c **** static uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 187:SYSTEM/fat16.c **** static uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint1
 188:SYSTEM/fat16.c **** static uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 189:SYSTEM/fat16.c **** static uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 190:SYSTEM/fat16.c **** static uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry
 191:SYSTEM/fat16.c **** 
 192:SYSTEM/fat16.c **** static uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p);
 193:SYSTEM/fat16.c **** 
 194:SYSTEM/fat16.c **** /**
 195:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 196:SYSTEM/fat16.c ****  * Opens a FAT16 filesystem.
 197:SYSTEM/fat16.c ****  *
 198:SYSTEM/fat16.c ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 199:SYSTEM/fat16.c ****  * \returns 0 on error, a FAT16 filesystem descriptor on success.
 200:SYSTEM/fat16.c ****  * \see fat16_open
 201:SYSTEM/fat16.c ****  */
 202:SYSTEM/fat16.c **** struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
 203:SYSTEM/fat16.c **** {
 204:SYSTEM/fat16.c ****     if(!partition ||
 205:SYSTEM/fat16.c ****         #if FAT16_WRITE_SUPPORT
 206:SYSTEM/fat16.c ****         !partition->device_write
 207:SYSTEM/fat16.c ****        #else
 208:SYSTEM/fat16.c ****         0
 209:SYSTEM/fat16.c ****        #endif
 210:SYSTEM/fat16.c ****        )
 211:SYSTEM/fat16.c ****     return 0;
 212:SYSTEM/fat16.c **** 
 213:SYSTEM/fat16.c ****     struct fat16_fs_struct* fs = malloc(sizeof(*fs));
 214:SYSTEM/fat16.c ****     if(!fs)
 215:SYSTEM/fat16.c ****     {
 216:SYSTEM/fat16.c ****         rprintf("MALLOC FAILS\n\r");
 217:SYSTEM/fat16.c ****         return 0;
 218:SYSTEM/fat16.c ****     }
 219:SYSTEM/fat16.c ****     memset(fs, 0, sizeof(*fs));
 220:SYSTEM/fat16.c **** 
 221:SYSTEM/fat16.c ****     fs->partition = partition;
 222:SYSTEM/fat16.c ****     if(!fat16_read_header(fs))
 223:SYSTEM/fat16.c ****     {
 224:SYSTEM/fat16.c ****         rprintf("Failed Reading Header\n\r");
 225:SYSTEM/fat16.c ****         free(fs);
 226:SYSTEM/fat16.c ****         return 0;
 227:SYSTEM/fat16.c ****     }
 228:SYSTEM/fat16.c **** 
 229:SYSTEM/fat16.c ****     return fs;
 230:SYSTEM/fat16.c **** }
 231:SYSTEM/fat16.c **** 
 232:SYSTEM/fat16.c **** /**
 233:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 234:SYSTEM/fat16.c ****  * Closes a FAT16 filesystem.
 235:SYSTEM/fat16.c ****  *
 236:SYSTEM/fat16.c ****  * When this function returns, the given filesystem descriptor
 237:SYSTEM/fat16.c ****  * will be invalid.
 238:SYSTEM/fat16.c ****  *
 239:SYSTEM/fat16.c ****  * \param[in] fs The filesystem to close.
 240:SYSTEM/fat16.c ****  * \see fat16_open
 241:SYSTEM/fat16.c ****  */
 242:SYSTEM/fat16.c **** void fat16_close(struct fat16_fs_struct* fs)
 243:SYSTEM/fat16.c **** {
 244:SYSTEM/fat16.c ****     if(!fs)
 245:SYSTEM/fat16.c ****         return;
 246:SYSTEM/fat16.c **** 
 247:SYSTEM/fat16.c ****     free(fs);
 248:SYSTEM/fat16.c **** }
 249:SYSTEM/fat16.c **** 
 250:SYSTEM/fat16.c **** /**
 251:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 252:SYSTEM/fat16.c ****  * Reads and parses the header of a FAT16 filesystem.
 253:SYSTEM/fat16.c ****  *
 254:SYSTEM/fat16.c ****  * \param[inout] fs The filesystem for which to parse the header.
 255:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
 256:SYSTEM/fat16.c ****  */
 257:SYSTEM/fat16.c **** uint8_t fat16_read_header(struct fat16_fs_struct* fs)
 258:SYSTEM/fat16.c **** {
 259:SYSTEM/fat16.c ****     if(!fs)
 260:SYSTEM/fat16.c ****         return 0;
 261:SYSTEM/fat16.c **** 
 262:SYSTEM/fat16.c ****     struct partition_struct* partition = fs->partition;
 263:SYSTEM/fat16.c ****     if(!partition)
 264:SYSTEM/fat16.c ****     {
 265:SYSTEM/fat16.c ****         rprintf("Partition = 0\n\r");
 266:SYSTEM/fat16.c ****         return 0;
 267:SYSTEM/fat16.c ****     }
 268:SYSTEM/fat16.c **** 
 269:SYSTEM/fat16.c ****     /* read fat parameters */
 270:SYSTEM/fat16.c ****     uint8_t buffer[25];
 271:SYSTEM/fat16.c ****     uint32_t partition_offset = partition->offset * 512;
 272:SYSTEM/fat16.c **** 
 273:SYSTEM/fat16.c ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
 274:SYSTEM/fat16.c ****         return 0;
 275:SYSTEM/fat16.c **** 
 276:SYSTEM/fat16.c ****     uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
 277:SYSTEM/fat16.c ****     ((uint16_t) buffer[0x01] << 8);
 278:SYSTEM/fat16.c ****     uint8_t sectors_per_cluster = buffer[0x02];
 279:SYSTEM/fat16.c ****     uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
 280:SYSTEM/fat16.c ****     ((uint16_t) buffer[0x04] << 8);
 281:SYSTEM/fat16.c ****     uint8_t fat_copies = buffer[0x05];
 282:SYSTEM/fat16.c ****     uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
 283:SYSTEM/fat16.c ****     ((uint16_t) buffer[0x07] << 8);
 284:SYSTEM/fat16.c ****     uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
 285:SYSTEM/fat16.c ****     ((uint16_t) buffer[0x09] << 8);
 286:SYSTEM/fat16.c ****     uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
 287:SYSTEM/fat16.c ****     ((uint16_t) buffer[0x0c] << 8);
 288:SYSTEM/fat16.c ****     uint32_t sector_count = ((uint32_t) buffer[0x15]) |
 289:SYSTEM/fat16.c ****     ((uint32_t) buffer[0x16] << 8) |
 290:SYSTEM/fat16.c ****     ((uint32_t) buffer[0x17] << 16) |
 291:SYSTEM/fat16.c ****     ((uint32_t) buffer[0x18] << 24);
 292:SYSTEM/fat16.c **** 
 293:SYSTEM/fat16.c ****     if(sectors_per_fat == 0)
 294:SYSTEM/fat16.c ****     /* this is not a FAT16 */
 295:SYSTEM/fat16.c ****         return 0;
 296:SYSTEM/fat16.c **** 
 297:SYSTEM/fat16.c ****     if(sector_count == 0)
 298:SYSTEM/fat16.c ****     {
 299:SYSTEM/fat16.c ****         if(sector_count_16 == 0)
 300:SYSTEM/fat16.c ****     /* illegal volume size */
 301:SYSTEM/fat16.c ****             return 0;
 302:SYSTEM/fat16.c ****         else
 303:SYSTEM/fat16.c ****             sector_count = sector_count_16;
 304:SYSTEM/fat16.c ****     }
 305:SYSTEM/fat16.c **** 
 306:SYSTEM/fat16.c ****     /* ensure we really have a FAT16 fs here */
 307:SYSTEM/fat16.c ****     uint32_t data_sector_count = sector_count
 308:SYSTEM/fat16.c ****     - reserved_sectors
 309:SYSTEM/fat16.c ****     - (uint32_t) sectors_per_fat * fat_copies
 310:SYSTEM/fat16.c ****     - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
 311:SYSTEM/fat16.c ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 312:SYSTEM/fat16.c ****     if(data_cluster_count < 4085 || data_cluster_count >= 65525)
 313:SYSTEM/fat16.c ****     /* this is not a FAT16 */
 314:SYSTEM/fat16.c ****         return 0;
 315:SYSTEM/fat16.c **** 
 316:SYSTEM/fat16.c ****     partition->type = PARTITION_TYPE_FAT16;
 317:SYSTEM/fat16.c **** 
 318:SYSTEM/fat16.c ****     /* fill header information */
 319:SYSTEM/fat16.c ****     struct fat16_header_struct* header = &fs->header;
 320:SYSTEM/fat16.c ****     memset(header, 0, sizeof(*header));
 321:SYSTEM/fat16.c **** 
 322:SYSTEM/fat16.c ****     header->size = sector_count * bytes_per_sector;
 323:SYSTEM/fat16.c **** 
 324:SYSTEM/fat16.c ****     header->fat_offset = /* jump to partition */
 325:SYSTEM/fat16.c ****     partition_offset +
 326:SYSTEM/fat16.c ****     /* jump to fat */
 327:SYSTEM/fat16.c ****     (uint32_t) reserved_sectors * bytes_per_sector;
 328:SYSTEM/fat16.c ****     header->fat_size = (data_cluster_count + 2) * 2;
 329:SYSTEM/fat16.c **** 
 330:SYSTEM/fat16.c ****     header->sector_size = bytes_per_sector;
 331:SYSTEM/fat16.c ****     header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
 332:SYSTEM/fat16.c **** 
 333:SYSTEM/fat16.c ****     header->root_dir_offset = /* jump to fats */
 334:SYSTEM/fat16.c ****     header->fat_offset +
 335:SYSTEM/fat16.c ****     /* jump to root directory entries */
 336:SYSTEM/fat16.c ****     (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;
 337:SYSTEM/fat16.c **** 
 338:SYSTEM/fat16.c ****     header->cluster_zero_offset = /* jump to root directory entries */
 339:SYSTEM/fat16.c ****     header->root_dir_offset +
 340:SYSTEM/fat16.c ****     /* skip root directory entries */
 341:SYSTEM/fat16.c ****     (uint32_t) max_root_entries * 32;
 342:SYSTEM/fat16.c **** 
 343:SYSTEM/fat16.c ****     return 1;
 344:SYSTEM/fat16.c **** }
 345:SYSTEM/fat16.c **** 
 346:SYSTEM/fat16.c **** /**
 347:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 348:SYSTEM/fat16.c ****  * Reads a directory entry of the root directory.
 349:SYSTEM/fat16.c ****  *
 350:SYSTEM/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 351:SYSTEM/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 352:SYSTEM/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 353:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success
 354:SYSTEM/fat16.c ****  * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 355:SYSTEM/fat16.c ****  */
 356:SYSTEM/fat16.c **** uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat1
 357:SYSTEM/fat16.c **** {
 358:SYSTEM/fat16.c ****     if(!fs || !dir_entry)
 359:SYSTEM/fat16.c ****         return 0;
 360:SYSTEM/fat16.c **** 
 361:SYSTEM/fat16.c ****     /* we read from the root directory entry */
 362:SYSTEM/fat16.c ****     const struct fat16_header_struct* header = &fs->header;
 363:SYSTEM/fat16.c ****     device_read_interval_t device_read_interval = fs->partition->device_read_interval;
 364:SYSTEM/fat16.c ****     uint8_t buffer[32];
 365:SYSTEM/fat16.c **** 
 366:SYSTEM/fat16.c ****     /* seek to the n-th entry */
 367:SYSTEM/fat16.c ****     struct fat16_read_callback_arg arg;
 368:SYSTEM/fat16.c ****     memset(&arg, 0, sizeof(arg));
 369:SYSTEM/fat16.c ****     arg.entry_num = entry_num;
 370:SYSTEM/fat16.c ****     if(!device_read_interval(header->root_dir_offset,
 371:SYSTEM/fat16.c ****         buffer,
 372:SYSTEM/fat16.c ****        sizeof(buffer),
 373:SYSTEM/fat16.c ****        header->cluster_zero_offset - header->root_dir_offset,
 374:SYSTEM/fat16.c ****        fat16_dir_entry_seek_callback,
 375:SYSTEM/fat16.c ****        &arg) ||
 376:SYSTEM/fat16.c ****        arg.entry_offset == 0
 377:SYSTEM/fat16.c ****        )
 378:SYSTEM/fat16.c ****     return 0;
 379:SYSTEM/fat16.c **** 
 380:SYSTEM/fat16.c ****     /* read entry */
 381:SYSTEM/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 382:SYSTEM/fat16.c ****     if(!device_read_interval(arg.entry_offset,
 383:SYSTEM/fat16.c ****         buffer,
 384:SYSTEM/fat16.c ****        sizeof(buffer),
 385:SYSTEM/fat16.c ****        arg.byte_count,
 386:SYSTEM/fat16.c ****        fat16_dir_entry_read_callback,
 387:SYSTEM/fat16.c ****        dir_entry))
 388:SYSTEM/fat16.c ****     return 0;
 389:SYSTEM/fat16.c **** 
 390:SYSTEM/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 391:SYSTEM/fat16.c **** }
 392:SYSTEM/fat16.c **** 
 393:SYSTEM/fat16.c **** /**
 394:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 395:SYSTEM/fat16.c ****  * Reads a directory entry of a given parent directory.
 396:SYSTEM/fat16.c ****  *
 397:SYSTEM/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 398:SYSTEM/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 399:SYSTEM/fat16.c ****  * \param[in] parent Directory entry descriptor in which to read directory entry.
 400:SYSTEM/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 401:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success
 402:SYSTEM/fat16.c ****  * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 403:SYSTEM/fat16.c ****  */
 404:SYSTEM/fat16.c **** uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct
 405:SYSTEM/fat16.c **** {
 406:SYSTEM/fat16.c ****     if(!fs || !parent || !dir_entry)
 407:SYSTEM/fat16.c ****         return 0;
 408:SYSTEM/fat16.c **** 
 409:SYSTEM/fat16.c ****     /* we are in a parent directory and want to search within its directory entry table */
 410:SYSTEM/fat16.c ****     if(!(parent->attributes & FAT16_ATTRIB_DIR))
 411:SYSTEM/fat16.c ****         return 0;
 412:SYSTEM/fat16.c **** 
 413:SYSTEM/fat16.c ****     /* loop through all clusters of the directory */
 414:SYSTEM/fat16.c ****     uint8_t buffer[32];
 415:SYSTEM/fat16.c ****     uint32_t cluster_offset;
 416:SYSTEM/fat16.c ****     uint16_t cluster_size = fs->header.cluster_size;
 417:SYSTEM/fat16.c ****     uint16_t cluster_num = parent->cluster;
 418:SYSTEM/fat16.c ****     struct fat16_read_callback_arg arg;
 419:SYSTEM/fat16.c **** 
 420:SYSTEM/fat16.c ****     while(1)
 421:SYSTEM/fat16.c ****     {
 422:SYSTEM/fat16.c ****         /* calculate new cluster offset */
 423:SYSTEM/fat16.c ****         cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_si
 424:SYSTEM/fat16.c **** 
 425:SYSTEM/fat16.c ****         /* seek to the n-th entry */
 426:SYSTEM/fat16.c ****         memset(&arg, 0, sizeof(arg));
 427:SYSTEM/fat16.c ****         arg.entry_num = entry_num;
 428:SYSTEM/fat16.c ****         if(!fs->partition->device_read_interval(cluster_offset,
 429:SYSTEM/fat16.c ****             buffer,
 430:SYSTEM/fat16.c ****            sizeof(buffer),
 431:SYSTEM/fat16.c ****            cluster_size,
 432:SYSTEM/fat16.c ****            fat16_dir_entry_seek_callback,
 433:SYSTEM/fat16.c ****            &arg)
 434:SYSTEM/fat16.c ****            )
 435:SYSTEM/fat16.c ****         return 0;
 436:SYSTEM/fat16.c **** 
 437:SYSTEM/fat16.c ****         /* check if we found the entry */
 438:SYSTEM/fat16.c ****         if(arg.entry_offset)
 439:SYSTEM/fat16.c ****             break;
 440:SYSTEM/fat16.c **** 
 441:SYSTEM/fat16.c ****         /* get number of next cluster */
 442:SYSTEM/fat16.c ****         if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
 443:SYSTEM/fat16.c ****             return 0; /* directory entry not found */
 444:SYSTEM/fat16.c ****     }
 445:SYSTEM/fat16.c **** 
 446:SYSTEM/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 447:SYSTEM/fat16.c **** 
 448:SYSTEM/fat16.c ****     /* read entry */
 449:SYSTEM/fat16.c ****     if(!fs->partition->device_read_interval(arg.entry_offset,
 450:SYSTEM/fat16.c ****         buffer,
 451:SYSTEM/fat16.c ****        sizeof(buffer),
 452:SYSTEM/fat16.c ****        arg.byte_count,
 453:SYSTEM/fat16.c ****        fat16_dir_entry_read_callback,
 454:SYSTEM/fat16.c ****        dir_entry))
 455:SYSTEM/fat16.c ****     return 0;
 456:SYSTEM/fat16.c **** 
 457:SYSTEM/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 458:SYSTEM/fat16.c **** }
 459:SYSTEM/fat16.c **** 
 460:SYSTEM/fat16.c **** /**
 461:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 462:SYSTEM/fat16.c ****  * Callback function for seeking through subdirectory entries.
 463:SYSTEM/fat16.c ****  */
 464:SYSTEM/fat16.c **** uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
 465:SYSTEM/fat16.c **** {
  25              		.loc 1 465 0
  26              		@ Function supports interworking.
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
 466:SYSTEM/fat16.c ****     struct fat16_read_callback_arg* arg = p;
 467:SYSTEM/fat16.c **** 
 468:SYSTEM/fat16.c ****     /* skip deleted or empty entries */
 469:SYSTEM/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
  31              		.loc 1 469 0
  32 0000 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  33 0004 E50053E3 		cmp	r3, #229
  34 0008 00005313 		cmpne	r3, #0
  35 000c 1500000A 		beq	.L2
 470:SYSTEM/fat16.c ****         return 1;
 471:SYSTEM/fat16.c **** 
 472:SYSTEM/fat16.c ****     if(arg->entry_cur == arg->entry_num)
  36              		.loc 1 472 0
  37 0010 B030D2E1 		ldrh	r3, [r2, #0]
  38 0014 B2C0D2E1 		ldrh	ip, [r2, #2]
  39 0018 03005CE1 		cmp	ip, r3
  40 001c 0B00001A 		bne	.L3
 473:SYSTEM/fat16.c ****     {
 474:SYSTEM/fat16.c ****         arg->entry_offset = offset;
  41              		.loc 1 474 0
  42 0020 041082E5 		str	r1, [r2, #4]
 475:SYSTEM/fat16.c ****         arg->byte_count = buffer[11] == 0x0f ?
  43              		.loc 1 475 0
  44 0024 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
  45 0028 0F0053E3 		cmp	r3, #15
  46 002c 0030D005 		ldreqb	r3, [r0, #0]	@ zero_extendqisi2
  47 0030 3F300302 		andeq	r3, r3, #63
  48 0034 01308302 		addeq	r3, r3, #1
  49 0038 8332A001 		moveq	r3, r3, asl #5
  50 003c 2030A013 		movne	r3, #32
  51 0040 FF300302 		andeq	r3, r3, #255
  52 0044 0830C2E5 		strb	r3, [r2, #8]
  53 0048 0000A0E3 		mov	r0, #0
  54              	.LVL1:
 476:SYSTEM/fat16.c ****         ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
 477:SYSTEM/fat16.c ****         32;
 478:SYSTEM/fat16.c ****         return 0;
  55              		.loc 1 478 0
  56 004c 1EFF2FE1 		bx	lr
  57              	.LVL2:
  58              	.L3:
 479:SYSTEM/fat16.c ****     }
 480:SYSTEM/fat16.c **** 
 481:SYSTEM/fat16.c ****     /* if we read a 8.3 entry, we reached a new directory entry */
 482:SYSTEM/fat16.c ****     if(buffer[11] != 0x0f)
  59              		.loc 1 482 0
  60 0050 0B10D0E5 		ldrb	r1, [r0, #11]	@ zero_extendqisi2
  61              	.LVL3:
  62 0054 0F0051E3 		cmp	r1, #15
 483:SYSTEM/fat16.c ****         ++arg->entry_cur;
  63              		.loc 1 483 0
  64 0058 01308312 		addne	r3, r3, #1
  65 005c B030C211 		strneh	r3, [r2, #0]	@ movhi
  66 0060 0100A013 		movne	r0, #1
  67              	.LVL4:
  68              		.loc 1 482 0
  69 0064 1EFF2F11 		bxne	lr
  70              	.LVL5:
  71              	.L2:
  72              		.loc 1 483 0
  73 0068 0100A0E3 		mov	r0, #1
  74              	.LVL6:
 484:SYSTEM/fat16.c **** 
 485:SYSTEM/fat16.c ****     return 1;
 486:SYSTEM/fat16.c **** }
  75              		.loc 1 486 0
  76 006c 1EFF2FE1 		bx	lr
  77              	.LFE5:
  79              		.align	2
  81              	fat16_dir_entry_read_callback:
  82              	.LFB6:
 487:SYSTEM/fat16.c **** 
 488:SYSTEM/fat16.c **** /**
 489:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 490:SYSTEM/fat16.c ****  * Callback function for reading a directory entry.
 491:SYSTEM/fat16.c ****  */
 492:SYSTEM/fat16.c **** uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
 493:SYSTEM/fat16.c **** {
  83              		.loc 1 493 0
  84              		@ Function supports interworking.
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88              	.LVL7:
  89 0070 30002DE9 		stmfd	sp!, {r4, r5}
  90              	.LCFI0:
 494:SYSTEM/fat16.c ****     struct fat16_dir_entry_struct* dir_entry = p;
 495:SYSTEM/fat16.c **** 
 496:SYSTEM/fat16.c ****     /* there should not be any deleted or empty entries */
 497:SYSTEM/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
  91              		.loc 1 497 0
  92 0074 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  93 0078 E50053E3 		cmp	r3, #229
  94 007c 00005313 		cmpne	r3, #0
  95 0080 0000A003 		moveq	r0, #0
  96              	.LVL8:
  97 0084 6200000A 		beq	.L11
 498:SYSTEM/fat16.c ****         return 0;
 499:SYSTEM/fat16.c **** 
 500:SYSTEM/fat16.c ****     if(!dir_entry->entry_offset)
  98              		.loc 1 500 0
  99 0088 283092E5 		ldr	r3, [r2, #40]
 100 008c 000053E3 		cmp	r3, #0
 501:SYSTEM/fat16.c ****         dir_entry->entry_offset = offset;
 101              		.loc 1 501 0
 102 0090 28108205 		streq	r1, [r2, #40]
 103              	.LBB17:
 104              	.LBB18:
 502:SYSTEM/fat16.c **** 
 503:SYSTEM/fat16.c ****     switch(fat16_interpret_dir_entry(dir_entry, buffer))
 504:SYSTEM/fat16.c ****     {
 505:SYSTEM/fat16.c ****         case 0: /* failure */
 506:SYSTEM/fat16.c ****             return 0;
 507:SYSTEM/fat16.c ****             case 1: /* buffer successfully parsed, continue */
 508:SYSTEM/fat16.c ****             return 1;
 509:SYSTEM/fat16.c ****             case 2: /* directory entry complete, finish */
 510:SYSTEM/fat16.c ****             return 0;
 511:SYSTEM/fat16.c ****         }
 512:SYSTEM/fat16.c **** 
 513:SYSTEM/fat16.c ****     return 0;
 514:SYSTEM/fat16.c **** }
 515:SYSTEM/fat16.c **** 
 516:SYSTEM/fat16.c **** /**
 517:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 518:SYSTEM/fat16.c ****  * Interprets a raw directory entry and puts the contained
 519:SYSTEM/fat16.c ****  * information into the directory entry.
 520:SYSTEM/fat16.c ****  *
 521:SYSTEM/fat16.c ****  * For a single file there may exist multiple directory
 522:SYSTEM/fat16.c ****  * entries. All except the last one are lfn entries, which
 523:SYSTEM/fat16.c ****  * contain parts of the long filename. The last directory
 524:SYSTEM/fat16.c ****  * entry is a traditional 8.3 style one. It contains all
 525:SYSTEM/fat16.c ****  * other information like size, cluster, date and time.
 526:SYSTEM/fat16.c ****  *
 527:SYSTEM/fat16.c ****  * \param[in,out] dir_entry The directory entry to fill.
 528:SYSTEM/fat16.c ****  * \param[in] raw_entry A pointer to 32 bytes of raw data.
 529:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success and 2 if the
 530:SYSTEM/fat16.c ****  *          directory entry is complete.
 531:SYSTEM/fat16.c ****  */
 532:SYSTEM/fat16.c **** uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entr
 533:SYSTEM/fat16.c **** {
 534:SYSTEM/fat16.c ****     if(!dir_entry || !raw_entry || !raw_entry[0])
 105              		.loc 1 534 0
 106 0094 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 107              	.LVL9:
 108 0098 000053E3 		cmp	r3, #0
 109 009c 5A00000A 		beq	.L14
 535:SYSTEM/fat16.c ****         return 0;
 536:SYSTEM/fat16.c **** 
 537:SYSTEM/fat16.c ****     char* long_name = dir_entry->long_name;
 538:SYSTEM/fat16.c ****     if(raw_entry[11] == 0x0f)
 110              		.loc 1 538 0
 111 00a0 0B10D0E5 		ldrb	r1, [r0, #11]	@ zero_extendqisi2
 112              	.LVL10:
 113 00a4 0F0051E3 		cmp	r1, #15
 114 00a8 2500001A 		bne	.L15
 115              	.LBB19:
 539:SYSTEM/fat16.c ****     {
 540:SYSTEM/fat16.c ****         uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
 116              		.loc 1 540 0
 117 00ac 3F3003E2 		and	r3, r3, #63
 118 00b0 0D10A0E3 		mov	r1, #13
 119 00b4 013043E2 		sub	r3, r3, #1
 120 00b8 910303E0 		mul	r3, r1, r3
 121 00bc 0338A0E1 		mov	r3, r3, asl #16
 122 00c0 2318A0E1 		mov	r1, r3, lsr #16
 123              	.LVL11:
 541:SYSTEM/fat16.c **** 
 542:SYSTEM/fat16.c ****         if(char_offset + 12 < sizeof(dir_entry->long_name))
 124              		.loc 1 542 0
 125 00c4 0CC081E2 		add	ip, r1, #12
 126 00c8 1F005CE3 		cmp	ip, #31
 127 00cc 1A00008A 		bhi	.L25
 543:SYSTEM/fat16.c ****         {
 544:SYSTEM/fat16.c ****             /* Lfn supports unicode, but we do not, for now.
 545:SYSTEM/fat16.c ****                                                  * So we assume pure ascii and read only every
 546:SYSTEM/fat16.c ****                                                  * second byte.
 547:SYSTEM/fat16.c ****                                                  */
 548:SYSTEM/fat16.c ****             long_name[char_offset + 0] = raw_entry[1];
 128              		.loc 1 548 0
 129 00d0 01C0D0E5 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
 130 00d4 23C8C2E7 		strb	ip, [r2, r3, lsr #16]
 549:SYSTEM/fat16.c ****             long_name[char_offset + 1] = raw_entry[3];
 131              		.loc 1 549 0
 132 00d8 0330D0E5 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 133 00dc 012082E0 		add	r2, r2, r1
 134              	.LVL12:
 135 00e0 0130C2E5 		strb	r3, [r2, #1]
 550:SYSTEM/fat16.c ****             long_name[char_offset + 2] = raw_entry[5];
 136              		.loc 1 550 0
 137 00e4 0530D0E5 		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 138 00e8 0230C2E5 		strb	r3, [r2, #2]
 551:SYSTEM/fat16.c ****             long_name[char_offset + 3] = raw_entry[7];
 139              		.loc 1 551 0
 140 00ec 0730D0E5 		ldrb	r3, [r0, #7]	@ zero_extendqisi2
 141 00f0 0330C2E5 		strb	r3, [r2, #3]
 552:SYSTEM/fat16.c ****             long_name[char_offset + 4] = raw_entry[9];
 142              		.loc 1 552 0
 143 00f4 0930D0E5 		ldrb	r3, [r0, #9]	@ zero_extendqisi2
 144 00f8 0430C2E5 		strb	r3, [r2, #4]
 553:SYSTEM/fat16.c ****             long_name[char_offset + 5] = raw_entry[14];
 145              		.loc 1 553 0
 146 00fc 0E30D0E5 		ldrb	r3, [r0, #14]	@ zero_extendqisi2
 147 0100 0530C2E5 		strb	r3, [r2, #5]
 554:SYSTEM/fat16.c ****             long_name[char_offset + 6] = raw_entry[16];
 148              		.loc 1 554 0
 149 0104 1030D0E5 		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 150 0108 0630C2E5 		strb	r3, [r2, #6]
 555:SYSTEM/fat16.c ****             long_name[char_offset + 7] = raw_entry[18];
 151              		.loc 1 555 0
 152 010c 1230D0E5 		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 153 0110 0730C2E5 		strb	r3, [r2, #7]
 556:SYSTEM/fat16.c ****             long_name[char_offset + 8] = raw_entry[20];
 154              		.loc 1 556 0
 155 0114 1430D0E5 		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 156 0118 0830C2E5 		strb	r3, [r2, #8]
 557:SYSTEM/fat16.c ****             long_name[char_offset + 9] = raw_entry[22];
 157              		.loc 1 557 0
 158 011c 1630D0E5 		ldrb	r3, [r0, #22]	@ zero_extendqisi2
 159 0120 0930C2E5 		strb	r3, [r2, #9]
 558:SYSTEM/fat16.c ****             long_name[char_offset + 10] = raw_entry[24];
 160              		.loc 1 558 0
 161 0124 1830D0E5 		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 162 0128 0A30C2E5 		strb	r3, [r2, #10]
 559:SYSTEM/fat16.c ****             long_name[char_offset + 11] = raw_entry[28];
 163              		.loc 1 559 0
 164 012c 1C30D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 165 0130 0B30C2E5 		strb	r3, [r2, #11]
 560:SYSTEM/fat16.c ****             long_name[char_offset + 12] = raw_entry[30];
 166              		.loc 1 560 0
 167 0134 1E30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 168 0138 0C30C2E5 		strb	r3, [r2, #12]
 169              	.LVL13:
 170              	.L25:
 171 013c 0130A0E3 		mov	r3, #1
 172 0140 310000EA 		b	.L14
 173              	.LVL14:
 174              	.L15:
 175              	.LBE19:
 561:SYSTEM/fat16.c ****         }
 562:SYSTEM/fat16.c **** 
 563:SYSTEM/fat16.c ****         return 1;
 564:SYSTEM/fat16.c ****     }
 565:SYSTEM/fat16.c ****     else
 566:SYSTEM/fat16.c ****     {
 567:SYSTEM/fat16.c ****         /* if we do not have a long name, take the short one */
 568:SYSTEM/fat16.c ****         if(long_name[0] == '\0')
 176              		.loc 1 568 0
 177 0144 0010D2E5 		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 178 0148 000051E3 		cmp	r1, #0
 179 014c 1E00001A 		bne	.L17
 180 0150 0130A0E1 		mov	r3, r1
 181              	.LVL15:
 182              	.L19:
 183              	.LBB20:
 569:SYSTEM/fat16.c ****         {
 570:SYSTEM/fat16.c ****             uint8_t i;
 571:SYSTEM/fat16.c ****             for(i = 0; i < 8; ++i)
 572:SYSTEM/fat16.c ****             {
 573:SYSTEM/fat16.c ****                 if(raw_entry[i] == ' ')
 184              		.loc 1 573 0
 185 0154 01C0D0E7 		ldrb	ip, [r0, r1]	@ zero_extendqisi2
 186 0158 20005CE3 		cmp	ip, #32
 187              		.loc 1 571 0
 188 015c 014083E2 		add	r4, r3, #1
 189              		.loc 1 573 0
 190 0160 0400000A 		beq	.L18
 191              		.loc 1 571 0
 192 0164 FF3004E2 		and	r3, r4, #255
 193              	.LVL16:
 194 0168 080053E3 		cmp	r3, #8
 574:SYSTEM/fat16.c ****                     break;
 575:SYSTEM/fat16.c ****                 long_name[i] = raw_entry[i];
 195              		.loc 1 575 0
 196 016c 01C0C2E7 		strb	ip, [r2, r1]
 197              		.loc 1 571 0
 198 0170 011081E2 		add	r1, r1, #1
 199 0174 F6FFFF1A 		bne	.L19
 200              	.L18:
 576:SYSTEM/fat16.c ****             }
 577:SYSTEM/fat16.c ****             if(raw_entry[8] != ' ')
 201              		.loc 1 577 0
 202 0178 0810D0E5 		ldrb	r1, [r0, #8]	@ zero_extendqisi2
 203 017c 200051E3 		cmp	r1, #32
 204 0180 0F00000A 		beq	.L20
 205              	.LBB21:
 206              		.loc 1 492 0
 207 0184 044083E2 		add	r4, r3, #4
 578:SYSTEM/fat16.c ****             {
 579:SYSTEM/fat16.c ****                 long_name[i++] = '.';
 208              		.loc 1 579 0
 209 0188 011083E2 		add	r1, r3, #1
 210              	.LVL17:
 211 018c 2EC0A0E3 		mov	ip, #46
 212 0190 03C0C2E7 		strb	ip, [r2, r3]
 213              		.loc 1 492 0
 214 0194 FF4004E2 		and	r4, r4, #255
 215 0198 FF3001E2 		and	r3, r1, #255
 216              	.LVL18:
 217              		.loc 1 579 0
 218 019c 0010A0E1 		mov	r1, r0
 219              	.L21:
 580:SYSTEM/fat16.c **** 
 581:SYSTEM/fat16.c ****                 uint8_t j = 8;
 582:SYSTEM/fat16.c ****                 for(; j < 11; ++j)
 583:SYSTEM/fat16.c ****                 {
 584:SYSTEM/fat16.c ****                     if(raw_entry[j] != ' ')
 220              		.loc 1 584 0
 221 01a0 08C0D1E5 		ldrb	ip, [r1, #8]	@ zero_extendqisi2
 222 01a4 20005CE3 		cmp	ip, #32
 585:SYSTEM/fat16.c ****                     {
 586:SYSTEM/fat16.c ****                         long_name[i++] = raw_entry[j];
 223              		.loc 1 586 0
 224 01a8 015083E2 		add	r5, r3, #1
 225              		.loc 1 584 0
 226 01ac 0400000A 		beq	.L20
 227              		.loc 1 586 0
 228 01b0 03C0C2E7 		strb	ip, [r2, r3]
 229 01b4 FF3005E2 		and	r3, r5, #255
 230              	.LVL19:
 231              		.loc 1 582 0
 232 01b8 040053E1 		cmp	r3, r4
 233              		.loc 1 586 0
 234 01bc 011081E2 		add	r1, r1, #1
 235              		.loc 1 582 0
 236 01c0 F6FFFF1A 		bne	.L21
 237              	.L20:
 238              	.LBE21:
 587:SYSTEM/fat16.c ****                     }
 588:SYSTEM/fat16.c ****                     else
 589:SYSTEM/fat16.c ****                     {
 590:SYSTEM/fat16.c ****                         break;
 591:SYSTEM/fat16.c ****                     }
 592:SYSTEM/fat16.c ****                 }
 593:SYSTEM/fat16.c ****             }
 594:SYSTEM/fat16.c **** 
 595:SYSTEM/fat16.c ****             long_name[i] = '\0';
 239              		.loc 1 595 0
 240 01c4 0010A0E3 		mov	r1, #0
 241 01c8 0310C2E7 		strb	r1, [r2, r3]
 242              	.L17:
 243              	.LBE20:
 596:SYSTEM/fat16.c ****         }
 597:SYSTEM/fat16.c **** 
 598:SYSTEM/fat16.c ****         /* extract properties of file and store them within the structure */
 599:SYSTEM/fat16.c ****         dir_entry->attributes = raw_entry[11];
 244              		.loc 1 599 0
 245 01cc 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 246              	.LVL20:
 247 01d0 2030C2E5 		strb	r3, [r2, #32]
 600:SYSTEM/fat16.c ****         dir_entry->cluster = ((uint16_t) raw_entry[26]) |
 248              		.loc 1 600 0
 249 01d4 1B10D0E5 		ldrb	r1, [r0, #27]	@ zero_extendqisi2
 250 01d8 1A30D0E5 		ldrb	r3, [r0, #26]	@ zero_extendqisi2
 251 01dc 013483E1 		orr	r3, r3, r1, asl #8
 252 01e0 B232C2E1 		strh	r3, [r2, #34]	@ movhi
 601:SYSTEM/fat16.c ****         ((uint16_t) raw_entry[27] << 8);
 602:SYSTEM/fat16.c ****         dir_entry->file_size = ((uint32_t) raw_entry[28]) |
 253              		.loc 1 602 0
 254 01e4 1E30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 255 01e8 1D10D0E5 		ldrb	r1, [r0, #29]	@ zero_extendqisi2
 256 01ec 1CC0D0E5 		ldrb	ip, [r0, #28]	@ zero_extendqisi2
 257 01f0 0338A0E1 		mov	r3, r3, asl #16
 258 01f4 013483E1 		orr	r3, r3, r1, asl #8
 259 01f8 1F10D0E5 		ldrb	r1, [r0, #31]	@ zero_extendqisi2
 260 01fc 0C3083E1 		orr	r3, r3, ip
 261 0200 013C83E1 		orr	r3, r3, r1, asl #24
 262 0204 243082E5 		str	r3, [r2, #36]
 263 0208 0230A0E3 		mov	r3, #2
 264              	.LVL21:
 265              	.L14:
 266 020c 08209FE5 		ldr	r2, .L26
 267              	.LVL22:
 268 0210 0300D2E7 		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 269              	.LVL23:
 270              	.L11:
 271              	.LBE18:
 272              	.LBE17:
 273              		.loc 1 514 0
 274 0214 3000BDE8 		ldmfd	sp!, {r4, r5}
 275 0218 1EFF2FE1 		bx	lr
 276              	.L27:
 277              		.align	2
 278              	.L26:
 279 021c 00000000 		.word	.LANCHOR0
 280              	.LFE6:
 282              		.align	2
 284              	fat16_get_next_cluster:
 285              	.LFB9:
 603:SYSTEM/fat16.c ****         ((uint32_t) raw_entry[29] << 8) |
 604:SYSTEM/fat16.c ****         ((uint32_t) raw_entry[30] << 16) |
 605:SYSTEM/fat16.c ****         ((uint32_t) raw_entry[31] << 24);
 606:SYSTEM/fat16.c **** 
 607:SYSTEM/fat16.c ****         return 2;
 608:SYSTEM/fat16.c ****     }
 609:SYSTEM/fat16.c **** }
 610:SYSTEM/fat16.c **** 
 611:SYSTEM/fat16.c **** /**
 612:SYSTEM/fat16.c ****  * \ingroup fat16_file
 613:SYSTEM/fat16.c ****  * Retrieves the directory entry of a path.
 614:SYSTEM/fat16.c ****  *
 615:SYSTEM/fat16.c ****  * The given path may both describe a file or a directory.
 616:SYSTEM/fat16.c ****  *
 617:SYSTEM/fat16.c ****  * \param[in] fs The FAT16 filesystem on which to search.
 618:SYSTEM/fat16.c ****  * \param[in] path The path of which to read the directory entry.
 619:SYSTEM/fat16.c ****  * \param[out] dir_entry The directory entry to fill.
 620:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
 621:SYSTEM/fat16.c ****  * \see fat16_read_dir
 622:SYSTEM/fat16.c ****  */
 623:SYSTEM/fat16.c **** uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_
 624:SYSTEM/fat16.c **** {
 625:SYSTEM/fat16.c ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 626:SYSTEM/fat16.c ****         return 0;
 627:SYSTEM/fat16.c **** 
 628:SYSTEM/fat16.c ****     if(path[0] == '/')
 629:SYSTEM/fat16.c ****         ++path;
 630:SYSTEM/fat16.c **** 
 631:SYSTEM/fat16.c ****     /* begin with the root directory */
 632:SYSTEM/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 633:SYSTEM/fat16.c ****     dir_entry->attributes = FAT16_ATTRIB_DIR;
 634:SYSTEM/fat16.c **** 
 635:SYSTEM/fat16.c ****     if(path[0] == '\0')
 636:SYSTEM/fat16.c ****         return 1;
 637:SYSTEM/fat16.c **** 
 638:SYSTEM/fat16.c ****     while(1)
 639:SYSTEM/fat16.c ****     {
 640:SYSTEM/fat16.c ****         struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
 641:SYSTEM/fat16.c ****         if(!dd)
 642:SYSTEM/fat16.c ****             break;
 643:SYSTEM/fat16.c **** 
 644:SYSTEM/fat16.c ****         /* extract the next hierarchy we will search for */
 645:SYSTEM/fat16.c ****         const char* sep_pos = strchr(path, '/');
 646:SYSTEM/fat16.c ****         if(!sep_pos)
 647:SYSTEM/fat16.c ****             sep_pos = path + strlen(path);
 648:SYSTEM/fat16.c ****         uint8_t length_to_sep = sep_pos - path;
 649:SYSTEM/fat16.c **** 
 650:SYSTEM/fat16.c ****         /* read directory entries */
 651:SYSTEM/fat16.c ****         while(fat16_read_dir(dd, dir_entry))
 652:SYSTEM/fat16.c ****         {
 653:SYSTEM/fat16.c ****             /* check if we have found the next hierarchy */
 654:SYSTEM/fat16.c ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 655:SYSTEM/fat16.c ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 656:SYSTEM/fat16.c ****             continue;
 657:SYSTEM/fat16.c **** 
 658:SYSTEM/fat16.c ****             fat16_close_dir(dd);
 659:SYSTEM/fat16.c ****             dd = 0;
 660:SYSTEM/fat16.c **** 
 661:SYSTEM/fat16.c ****             if(path[length_to_sep] == '\0')
 662:SYSTEM/fat16.c ****     /* we iterated through the whole path and have found the file */
 663:SYSTEM/fat16.c ****                 return 1;
 664:SYSTEM/fat16.c **** 
 665:SYSTEM/fat16.c ****             if(dir_entry->attributes & FAT16_ATTRIB_DIR)
 666:SYSTEM/fat16.c ****             {
 667:SYSTEM/fat16.c ****                 /* we found a parent directory of the file we are searching for */
 668:SYSTEM/fat16.c ****                 path = sep_pos + 1;
 669:SYSTEM/fat16.c ****                 break;
 670:SYSTEM/fat16.c ****             }
 671:SYSTEM/fat16.c **** 
 672:SYSTEM/fat16.c ****             /* a parent of the file exists, but not the file itself */
 673:SYSTEM/fat16.c ****             return 0;
 674:SYSTEM/fat16.c ****         }
 675:SYSTEM/fat16.c **** 
 676:SYSTEM/fat16.c ****         fat16_close_dir(dd);
 677:SYSTEM/fat16.c ****     }
 678:SYSTEM/fat16.c **** 
 679:SYSTEM/fat16.c ****     return 0;
 680:SYSTEM/fat16.c **** }
 681:SYSTEM/fat16.c **** 
 682:SYSTEM/fat16.c **** /**
 683:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 684:SYSTEM/fat16.c ****  * Retrieves the next following cluster of a given cluster.
 685:SYSTEM/fat16.c ****  *
 686:SYSTEM/fat16.c ****  * Using the filesystem file allocation table, this function returns
 687:SYSTEM/fat16.c ****  * the number of the cluster containing the data directly following
 688:SYSTEM/fat16.c ****  * the data within the cluster with the given number.
 689:SYSTEM/fat16.c ****  *
 690:SYSTEM/fat16.c ****  * \param[in] fs The filesystem for which to determine the next cluster.
 691:SYSTEM/fat16.c ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 692:SYSTEM/fat16.c ****  * \returns The wanted cluster number, or 0 on error.
 693:SYSTEM/fat16.c ****  */
 694:SYSTEM/fat16.c **** uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 695:SYSTEM/fat16.c **** {
 286              		.loc 1 695 0
 287              		@ Function supports interworking.
 288              		@ args = 0, pretend = 0, frame = 8
 289              		@ frame_needed = 0, uses_anonymous_args = 0
 290              	.LVL24:
 696:SYSTEM/fat16.c ****     if(!fs || cluster_num < 2)
 291              		.loc 1 696 0
 292 0220 000050E3 		cmp	r0, #0
 293 0224 01005113 		cmpne	r1, #1
 294              		.loc 1 695 0
 295 0228 07402DE9 		stmfd	sp!, {r0, r1, r2, lr}
 296              	.LCFI1:
 297              	.LVL25:
 298              		.loc 1 696 0
 299 022c 0030A0E1 		mov	r3, r0
 300              	.LVL26:
 301 0230 1900009A 		bls	.L29
 302              	.LVL27:
 697:SYSTEM/fat16.c ****         return 0;
 698:SYSTEM/fat16.c **** 
 699:SYSTEM/fat16.c ****     /* read appropriate fat entry */
 700:SYSTEM/fat16.c ****     uint8_t fat_entry[2];
 701:SYSTEM/fat16.c ****     if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
 303              		.loc 1 701 0
 304 0234 080090E5 		ldr	r0, [r0, #8]
 305 0238 003093E5 		ldr	r3, [r3, #0]
 306              	.LVL28:
 307 023c 810080E0 		add	r0, r0, r1, asl #1
 308              	.LVL29:
 309 0240 0220A0E3 		mov	r2, #2
 310 0244 04108DE2 		add	r1, sp, #4
 311              	.LVL30:
 312 0248 00C093E5 		ldr	ip, [r3, #0]
 313 024c 0FE0A0E1 		mov	lr, pc
 314 0250 1CFF2FE1 		bx	ip
 315 0254 000050E3 		cmp	r0, #0
 316 0258 0F00000A 		beq	.L29
 702:SYSTEM/fat16.c ****         return 0;
 703:SYSTEM/fat16.c **** 
 704:SYSTEM/fat16.c ****     /* determine next cluster from fat */
 705:SYSTEM/fat16.c ****     cluster_num = ((uint16_t) fat_entry[0]) |
 317              		.loc 1 705 0
 318 025c 0500DDE5 		ldrb	r0, [sp, #5]	@ zero_extendqisi2
 319 0260 0420DDE5 		ldrb	r2, [sp, #4]	@ zero_extendqisi2
 706:SYSTEM/fat16.c ****     ((uint16_t) fat_entry[1] << 8);
 707:SYSTEM/fat16.c **** 	///*
 708:SYSTEM/fat16.c ****     if(cluster_num == FAT16_CLUSTER_FREE ||
 320              		.loc 1 708 0
 321 0264 3C309FE5 		ldr	r3, .L32
 322              		.loc 1 705 0
 323 0268 000482E1 		orr	r0, r2, r0, asl #8
 324              	.LVL31:
 325              		.loc 1 708 0
 326 026c 000050E3 		cmp	r0, #0
 327 0270 03005011 		cmpne	r0, r3
 328 0274 0800000A 		beq	.L29
 329 0278 102080E2 		add	r2, r0, #16
 330 027c 030050E1 		cmp	r0, r3
 331 0280 0030A093 		movls	r3, #0
 332 0284 0130A083 		movhi	r3, #1
 333 0288 0228A0E1 		mov	r2, r2, asl #16
 334 028c 060852E3 		cmp	r2, #393216
 335 0290 01308393 		orrls	r3, r3, #1
 336 0294 000053E3 		cmp	r3, #0
 337 0298 0000000A 		beq	.L30
 338              	.LVL32:
 339              	.L29:
 340 029c 0000A0E3 		mov	r0, #0
 341              	.LVL33:
 342              	.L30:
 343              	.LVL34:
 709:SYSTEM/fat16.c ****         cluster_num == FAT16_CLUSTER_BAD ||
 710:SYSTEM/fat16.c ****        (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
 711:SYSTEM/fat16.c ****        (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 712:SYSTEM/fat16.c ****     //*/
 713:SYSTEM/fat16.c **** 	return 0;
 714:SYSTEM/fat16.c **** 
 715:SYSTEM/fat16.c ****     return cluster_num;
 716:SYSTEM/fat16.c **** }
 344              		.loc 1 716 0
 345 02a0 0E40BDE8 		ldmfd	sp!, {r1, r2, r3, lr}
 346 02a4 1EFF2FE1 		bx	lr
 347              	.L33:
 348              		.align	2
 349              	.L32:
 350 02a8 F7FF0000 		.word	65527
 351              	.LFE9:
 353              		.align	2
 355              	fat16_free_clusters:
 356              	.LFB11:
 717:SYSTEM/fat16.c **** 
 718:SYSTEM/fat16.c **** /**
 719:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 720:SYSTEM/fat16.c ****  * Appends a new cluster chain to an existing one.
 721:SYSTEM/fat16.c ****  *
 722:SYSTEM/fat16.c ****  * Set cluster_num to zero to create a completely new one.
 723:SYSTEM/fat16.c ****  *
 724:SYSTEM/fat16.c ****  * \param[in] fs The file system on which to operate.
 725:SYSTEM/fat16.c ****  * \param[in] cluster_num The cluster to which to append the new chain.
 726:SYSTEM/fat16.c ****  * \param[in] count The number of clusters to allocate.
 727:SYSTEM/fat16.c ****  * \returns 0 on failure, the number of the first new cluster on success.
 728:SYSTEM/fat16.c ****  */
 729:SYSTEM/fat16.c **** uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t cou
 730:SYSTEM/fat16.c **** {
 731:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
 732:SYSTEM/fat16.c ****         if(!fs)
 733:SYSTEM/fat16.c ****             return 0;
 734:SYSTEM/fat16.c ****     
 735:SYSTEM/fat16.c ****         device_read_t device_read = fs->partition->device_read;
 736:SYSTEM/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 737:SYSTEM/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 738:SYSTEM/fat16.c ****         uint16_t cluster_max = fs->header.fat_size / 2;
 739:SYSTEM/fat16.c ****         uint16_t cluster_next = 0;
 740:SYSTEM/fat16.c ****         uint16_t count_left = count;
 741:SYSTEM/fat16.c ****         uint8_t buffer[2];
 742:SYSTEM/fat16.c ****         uint16_t cluster_new;
 743:SYSTEM/fat16.c ****         for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
 744:SYSTEM/fat16.c ****         {
 745:SYSTEM/fat16.c ****             if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 746:SYSTEM/fat16.c ****                 return 0;
 747:SYSTEM/fat16.c ****     
 748:SYSTEM/fat16.c ****             /* check if this is a free cluster */
 749:SYSTEM/fat16.c ****             if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
 750:SYSTEM/fat16.c ****                 buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
 751:SYSTEM/fat16.c ****             {
 752:SYSTEM/fat16.c ****                 /* allocate cluster */
 753:SYSTEM/fat16.c ****                 if(count_left == count)
 754:SYSTEM/fat16.c ****                 {
 755:SYSTEM/fat16.c ****                     buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 756:SYSTEM/fat16.c ****                     buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 757:SYSTEM/fat16.c ****                 }
 758:SYSTEM/fat16.c ****                 else
 759:SYSTEM/fat16.c ****                 {
 760:SYSTEM/fat16.c ****                     buffer[0] = cluster_next & 0xff;
 761:SYSTEM/fat16.c ****                     buffer[1] = (cluster_next >> 8) & 0xff;
 762:SYSTEM/fat16.c ****                 }
 763:SYSTEM/fat16.c ****     
 764:SYSTEM/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 765:SYSTEM/fat16.c ****                     break;
 766:SYSTEM/fat16.c ****     
 767:SYSTEM/fat16.c ****                 cluster_next = cluster_new;
 768:SYSTEM/fat16.c ****                 if(--count_left == 0)
 769:SYSTEM/fat16.c ****                     break;
 770:SYSTEM/fat16.c ****             }
 771:SYSTEM/fat16.c ****         }
 772:SYSTEM/fat16.c ****     
 773:SYSTEM/fat16.c ****         do
 774:SYSTEM/fat16.c ****         {
 775:SYSTEM/fat16.c ****             if(count_left > 0)
 776:SYSTEM/fat16.c ****                 break;
 777:SYSTEM/fat16.c ****     
 778:SYSTEM/fat16.c ****             /* We allocated a new cluster chain. Now join
 779:SYSTEM/fat16.c ****                                              * it with the existing one.
 780:SYSTEM/fat16.c ****                                              */
 781:SYSTEM/fat16.c ****             if(cluster_num >= 2)
 782:SYSTEM/fat16.c ****             {
 783:SYSTEM/fat16.c ****                 buffer[0] = cluster_next & 0xff;
 784:SYSTEM/fat16.c ****                 buffer[1] = (cluster_next >> 8) & 0xff;
 785:SYSTEM/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
 786:SYSTEM/fat16.c ****                     break;
 787:SYSTEM/fat16.c ****             }
 788:SYSTEM/fat16.c ****     
 789:SYSTEM/fat16.c ****             return cluster_next;
 790:SYSTEM/fat16.c ****     
 791:SYSTEM/fat16.c ****         }
 792:SYSTEM/fat16.c ****         while(0);
 793:SYSTEM/fat16.c ****     
 794:SYSTEM/fat16.c ****         /* No space left on device or writing error.
 795:SYSTEM/fat16.c ****                              * Free up all clusters already allocated.
 796:SYSTEM/fat16.c ****                              */
 797:SYSTEM/fat16.c ****         fat16_free_clusters(fs, cluster_next);
 798:SYSTEM/fat16.c ****     
 799:SYSTEM/fat16.c ****         return 0;
 800:SYSTEM/fat16.c ****     #else
 801:SYSTEM/fat16.c ****         return 0;
 802:SYSTEM/fat16.c ****     #endif
 803:SYSTEM/fat16.c **** }
 804:SYSTEM/fat16.c **** 
 805:SYSTEM/fat16.c **** /**
 806:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 807:SYSTEM/fat16.c ****  * Frees a cluster chain, or a part thereof.
 808:SYSTEM/fat16.c ****  *
 809:SYSTEM/fat16.c ****  * Marks the specified cluster and all clusters which are sequentially
 810:SYSTEM/fat16.c ****  * referenced by it as free. They may then be used again for future
 811:SYSTEM/fat16.c ****  * file allocations.
 812:SYSTEM/fat16.c ****  *
 813:SYSTEM/fat16.c ****  * \note If this function is used for freeing just a part of a cluster
 814:SYSTEM/fat16.c ****  *       chain, the new end of the chain is not correctly terminated
 815:SYSTEM/fat16.c ****  *       within the FAT. Use fat16_terminate_clusters() instead.
 816:SYSTEM/fat16.c ****  *
 817:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 818:SYSTEM/fat16.c ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 819:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
 820:SYSTEM/fat16.c ****  * \see fat16_terminate_clusters
 821:SYSTEM/fat16.c ****  */
 822:SYSTEM/fat16.c **** uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 823:SYSTEM/fat16.c **** {
 357              		.loc 1 823 0
 358              		@ Function supports interworking.
 359              		@ args = 0, pretend = 0, frame = 8
 360              		@ frame_needed = 0, uses_anonymous_args = 0
 361              	.LVL35:
 824:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
 825:SYSTEM/fat16.c ****         if(!fs || cluster_num < 2)
 362              		.loc 1 825 0
 363 02ac 000050E3 		cmp	r0, #0
 364 02b0 01005113 		cmpne	r1, #1
 365              		.loc 1 823 0
 366 02b4 F7452DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, sl, lr}
 367              	.LCFI2:
 368              	.LVL36:
 369              		.loc 1 825 0
 370 02b8 0050A0E1 		mov	r5, r0
 371              	.LVL37:
 372 02bc 0070A083 		movhi	r7, #0
 373 02c0 0170A093 		movls	r7, #1
 374 02c4 2200009A 		bls	.L35
 375              	.LVL38:
 826:SYSTEM/fat16.c ****             return 0;
 827:SYSTEM/fat16.c ****     
 828:SYSTEM/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 376              		.loc 1 828 0
 377 02c8 088090E5 		ldr	r8, [r0, #8]
 378              	.LVL39:
 379              	.LBB22:
 829:SYSTEM/fat16.c ****         uint8_t buffer[2];
 830:SYSTEM/fat16.c ****         while(cluster_num)
 831:SYSTEM/fat16.c ****         {
 832:SYSTEM/fat16.c ****             if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
 833:SYSTEM/fat16.c ****                 return 0;
 834:SYSTEM/fat16.c ****     
 835:SYSTEM/fat16.c ****             /* get next cluster of current cluster before freeing current cluster */
 836:SYSTEM/fat16.c ****             uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
 837:SYSTEM/fat16.c ****             ((uint16_t) buffer[1] << 8);
 838:SYSTEM/fat16.c ****     
 839:SYSTEM/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_FREE)
 840:SYSTEM/fat16.c ****                 return 1;
 841:SYSTEM/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_BAD ||
 842:SYSTEM/fat16.c ****                 (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 843:SYSTEM/fat16.c ****                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 844:SYSTEM/fat16.c ****                )
 845:SYSTEM/fat16.c ****                )
 846:SYSTEM/fat16.c ****             return 0;
 847:SYSTEM/fat16.c **** 			///*
 848:SYSTEM/fat16.c ****             if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
 380              		.loc 1 848 0
 381 02cc 94A09FE5 		ldr	sl, .L42
 382              		.loc 1 832 0
 383 02d0 04608DE2 		add	r6, sp, #4
 384              	.LVL40:
 385              	.L38:
 386 02d4 814088E0 		add	r4, r8, r1, asl #1
 387              	.LVL41:
 388 02d8 0220A0E3 		mov	r2, #2
 389 02dc 0610A0E1 		mov	r1, r6
 390              	.LVL42:
 391 02e0 003095E5 		ldr	r3, [r5, #0]
 392 02e4 0400A0E1 		mov	r0, r4
 393 02e8 00C093E5 		ldr	ip, [r3, #0]
 394 02ec 0FE0A0E1 		mov	lr, pc
 395 02f0 1CFF2FE1 		bx	ip
 396 02f4 000050E3 		cmp	r0, #0
 849:SYSTEM/fat16.c ****                 (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
 850:SYSTEM/fat16.c ****                )
 851:SYSTEM/fat16.c **** 			//*/
 852:SYSTEM/fat16.c ****             cluster_num_next = 0;
 853:SYSTEM/fat16.c ****     
 854:SYSTEM/fat16.c ****             /* free cluster */
 855:SYSTEM/fat16.c ****             buffer[0] = FAT16_CLUSTER_FREE & 0xff;
 856:SYSTEM/fat16.c ****             buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
 857:SYSTEM/fat16.c ****             fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
 397              		.loc 1 857 0
 398 02f8 0610A0E1 		mov	r1, r6
 399 02fc 0220A0E3 		mov	r2, #2
 400 0300 0400A0E1 		mov	r0, r4
 401              		.loc 1 832 0
 402 0304 1200000A 		beq	.L35
 403              		.loc 1 837 0
 404 0308 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 405 030c 0540DDE5 		ldrb	r4, [sp, #5]	@ zero_extendqisi2
 406              		.loc 1 839 0
 407 0310 044493E1 		orrs	r4, r3, r4, asl #8
 408              	.LVL43:
 409              		.loc 1 841 0
 410 0314 103084E2 		add	r3, r4, #16
 411 0318 0338A0E1 		mov	r3, r3, asl #16
 412              		.loc 1 839 0
 413 031c 0E00000A 		beq	.L36
 414              		.loc 1 841 0
 415 0320 070853E3 		cmp	r3, #458752
 416 0324 0A00009A 		bls	.L35
 417              		.loc 1 855 0
 418 0328 0470CDE5 		strb	r7, [sp, #4]
 419              		.loc 1 856 0
 420 032c 0570CDE5 		strb	r7, [sp, #5]
 421              		.loc 1 848 0
 422 0330 0A0054E1 		cmp	r4, sl
 423 0334 0040A083 		movhi	r4, #0
 424              	.LVL44:
 425              		.loc 1 857 0
 426 0338 003095E5 		ldr	r3, [r5, #0]
 427 033c 08C093E5 		ldr	ip, [r3, #8]
 428 0340 0FE0A0E1 		mov	lr, pc
 429 0344 1CFF2FE1 		bx	ip
 430              	.LBE22:
 431              		.loc 1 830 0
 432 0348 001054E2 		subs	r1, r4, #0
 433              	.LVL45:
 434 034c E0FFFF1A 		bne	.L38
 435 0350 010000EA 		b	.L36
 436              	.LVL46:
 437              	.L35:
 438 0354 0000A0E3 		mov	r0, #0
 439 0358 000000EA 		b	.L39
 440              	.LVL47:
 441              	.L36:
 442 035c 0100A0E3 		mov	r0, #1
 443              	.L39:
 858:SYSTEM/fat16.c ****     
 859:SYSTEM/fat16.c ****             /* We continue in any case here, even if freeing the cluster failed.
 860:SYSTEM/fat16.c ****                                              * The cluster is lost, but maybe we can still free up 
 861:SYSTEM/fat16.c ****                                              */
 862:SYSTEM/fat16.c ****     
 863:SYSTEM/fat16.c ****             cluster_num = cluster_num_next;
 864:SYSTEM/fat16.c ****         }
 865:SYSTEM/fat16.c ****     
 866:SYSTEM/fat16.c ****         return 1;
 867:SYSTEM/fat16.c ****     #else
 868:SYSTEM/fat16.c ****         return 0;
 869:SYSTEM/fat16.c ****     #endif
 870:SYSTEM/fat16.c **** }
 444              		.loc 1 870 0
 445 0360 FE45BDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, sl, lr}
 446 0364 1EFF2FE1 		bx	lr
 447              	.L43:
 448              		.align	2
 449              	.L42:
 450 0368 F7FF0000 		.word	65527
 451              	.LFE11:
 453              		.align	2
 455              	fat16_append_clusters:
 456              	.LFB10:
 457              		.loc 1 730 0
 458              		@ Function supports interworking.
 459              		@ args = 0, pretend = 0, frame = 32
 460              		@ frame_needed = 0, uses_anonymous_args = 0
 461              	.LVL48:
 462 036c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 463              	.LCFI3:
 464              		.loc 1 732 0
 465 0370 006050E2 		subs	r6, r0, #0
 466              		.loc 1 730 0
 467 0374 24D04DE2 		sub	sp, sp, #36
 468              	.LCFI4:
 469              		.loc 1 730 0
 470 0378 0C108DE5 		str	r1, [sp, #12]
 471 037c 02A0A0E1 		mov	sl, r2
 472              		.loc 1 732 0
 473 0380 4F00000A 		beq	.L45
 474              	.LVL49:
 475              		.loc 1 735 0
 476 0384 003096E5 		ldr	r3, [r6, #0]
 477              		.loc 1 737 0
 478              	.LVL50:
 479 0388 081086E2 		add	r1, r6, #8
 480 038c 060091E8 		ldmia	r1, {r1, r2}	@ phole ldm
 481 0390 04108DE5 		str	r1, [sp, #4]
 482              		.loc 1 738 0
 483 0394 8227A0E1 		mov	r2, r2, asl #15
 484              		.loc 1 736 0
 485 0398 081093E5 		ldr	r1, [r3, #8]
 486              		.loc 1 735 0
 487 039c 003093E5 		ldr	r3, [r3, #0]
 488              		.loc 1 738 0
 489 03a0 0040A0E3 		mov	r4, #0
 490              	.LVL51:
 491 03a4 2228A0E1 		mov	r2, r2, lsr #16
 492              		.loc 1 736 0
 493 03a8 08108DE5 		str	r1, [sp, #8]
 494              		.loc 1 738 0
 495 03ac 10208DE5 		str	r2, [sp, #16]
 496              		.loc 1 735 0
 497 03b0 14308DE5 		str	r3, [sp, #20]
 498              		.loc 1 738 0
 499 03b4 04809DE5 		ldr	r8, [sp, #4]
 500              	.LVL52:
 501 03b8 0A70A0E1 		mov	r7, sl
 502              	.LVL53:
 503 03bc 0450A0E1 		mov	r5, r4
 504              	.LVL54:
 505              		.loc 1 745 0
 506 03c0 1C908DE2 		add	r9, sp, #28
 507              		.loc 1 755 0
 508 03c4 00B0E0E3 		mvn	fp, #0
 509              		.loc 1 743 0
 510 03c8 260000EA 		b	.L46
 511              	.L53:
 512              		.loc 1 745 0
 513 03cc 0800A0E1 		mov	r0, r8
 514 03d0 0910A0E1 		mov	r1, r9
 515 03d4 0220A0E3 		mov	r2, #2
 516 03d8 14309DE5 		ldr	r3, [sp, #20]
 517 03dc 0FE0A0E1 		mov	lr, pc
 518 03e0 13FF2FE1 		bx	r3
 519 03e4 000050E3 		cmp	r0, #0
 520 03e8 3500000A 		beq	.L45
 521              		.loc 1 749 0
 522 03ec 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 523 03f0 000053E3 		cmp	r3, #0
 524 03f4 1700001A 		bne	.L47
 525              		.loc 1 750 0
 526 03f8 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 527 03fc 000053E3 		cmp	r3, #0
 528 0400 1400001A 		bne	.L47
 529              		.loc 1 753 0
 530 0404 0A0057E1 		cmp	r7, sl
 531              		.loc 1 755 0
 532 0408 0B10A001 		moveq	r1, fp
 533              		.loc 1 761 0
 534 040c 2434A011 		movne	r3, r4, lsr #8
 535              		.loc 1 755 0
 536 0410 1C10CD05 		streqb	r1, [sp, #28]
 537              		.loc 1 756 0
 538 0414 1D10CD05 		streqb	r1, [sp, #29]
 539              		.loc 1 761 0
 540 0418 1D30CD15 		strneb	r3, [sp, #29]
 541              		.loc 1 760 0
 542 041c 1C40CD15 		strneb	r4, [sp, #28]
 543              		.loc 1 764 0
 544 0420 0800A0E1 		mov	r0, r8
 545 0424 0910A0E1 		mov	r1, r9
 546 0428 0220A0E3 		mov	r2, #2
 547 042c 08309DE5 		ldr	r3, [sp, #8]
 548 0430 0FE0A0E1 		mov	lr, pc
 549 0434 13FF2FE1 		bx	r3
 550 0438 000050E3 		cmp	r0, #0
 551 043c 0C00000A 		beq	.L50
 552              		.loc 1 768 0
 553 0440 017047E2 		sub	r7, r7, #1
 554              	.LVL55:
 555 0444 0778A0E1 		mov	r7, r7, asl #16
 556 0448 2778B0E1 		movs	r7, r7, lsr #16
 557              	.LVL56:
 558 044c 0540A001 		moveq	r4, r5
 559              	.LVL57:
 560 0450 0900000A 		beq	.L52
 561              	.L51:
 562 0454 0540A0E1 		mov	r4, r5
 563              	.LVL58:
 564              	.L47:
 565              		.loc 1 743 0
 566 0458 015085E2 		add	r5, r5, #1
 567              	.LVL59:
 568 045c 0558A0E1 		mov	r5, r5, asl #16
 569 0460 2558A0E1 		mov	r5, r5, lsr #16
 570              	.LVL60:
 571 0464 028088E2 		add	r8, r8, #2
 572              	.LVL61:
 573              	.L46:
 574 0468 10109DE5 		ldr	r1, [sp, #16]
 575 046c 010055E1 		cmp	r5, r1
 576 0470 D5FFFF3A 		bcc	.L53
 577              	.L50:
 578              		.loc 1 775 0
 579 0474 000057E3 		cmp	r7, #0
 580 0478 0E00001A 		bne	.L54
 581              	.L52:
 582              		.loc 1 781 0
 583 047c 0C209DE5 		ldr	r2, [sp, #12]
 584 0480 010052E3 		cmp	r2, #1
 585 0484 0F00009A 		bls	.L55
 586              		.loc 1 784 0
 587 0488 2434A0E1 		mov	r3, r4, lsr #8
 588 048c 1D30CDE5 		strb	r3, [sp, #29]
 589              		.loc 1 785 0
 590 0490 04309DE5 		ldr	r3, [sp, #4]
 591              		.loc 1 783 0
 592 0494 1C40CDE5 		strb	r4, [sp, #28]
 593              		.loc 1 785 0
 594 0498 820083E0 		add	r0, r3, r2, asl #1
 595 049c 1C108DE2 		add	r1, sp, #28
 596 04a0 0220A0E3 		mov	r2, #2
 597 04a4 08309DE5 		ldr	r3, [sp, #8]
 598 04a8 0FE0A0E1 		mov	lr, pc
 599 04ac 13FF2FE1 		bx	r3
 600 04b0 000050E3 		cmp	r0, #0
 601 04b4 0300001A 		bne	.L55
 602              	.LVL62:
 603              	.L54:
 604              		.loc 1 797 0
 605 04b8 0410A0E1 		mov	r1, r4
 606 04bc 0600A0E1 		mov	r0, r6
 607 04c0 79FFFFEB 		bl	fat16_free_clusters
 608              	.LVL63:
 609              	.L45:
 610              		.loc 1 799 0
 611 04c4 0040A0E3 		mov	r4, #0
 612              	.LVL64:
 613              	.L55:
 614              		.loc 1 803 0
 615 04c8 0400A0E1 		mov	r0, r4
 616 04cc 24D08DE2 		add	sp, sp, #36
 617 04d0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 618 04d4 1EFF2FE1 		bx	lr
 619              	.LFE10:
 621              		.global	__aeabi_uidivmod
 622              		.align	2
 623              		.global	fat16_read_file
 625              	fat16_read_file:
 626              	.LFB15:
 871:SYSTEM/fat16.c **** 
 872:SYSTEM/fat16.c **** /**
 873:SYSTEM/fat16.c ****  * \ingroup fat16_fs
 874:SYSTEM/fat16.c ****  * Frees a part of a cluster chain and correctly terminates the rest.
 875:SYSTEM/fat16.c ****  *
 876:SYSTEM/fat16.c ****  * Marks the specified cluster as the new end of a cluster chain and
 877:SYSTEM/fat16.c ****  * frees all following clusters.
 878:SYSTEM/fat16.c ****  *
 879:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 880:SYSTEM/fat16.c ****  * \param[in] cluster_num The new end of the cluster chain.
 881:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
 882:SYSTEM/fat16.c ****  * \see fat16_free_clusters
 883:SYSTEM/fat16.c ****  */
 884:SYSTEM/fat16.c **** uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 885:SYSTEM/fat16.c **** {
 886:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
 887:SYSTEM/fat16.c ****         if(!fs || cluster_num < 2)
 888:SYSTEM/fat16.c ****             return 0;
 889:SYSTEM/fat16.c ****     
 890:SYSTEM/fat16.c ****         /* fetch next cluster before overwriting the cluster entry */
 891:SYSTEM/fat16.c ****         uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
 892:SYSTEM/fat16.c ****     
 893:SYSTEM/fat16.c ****         /* mark cluster as the last one */
 894:SYSTEM/fat16.c ****         uint8_t buffer[2];
 895:SYSTEM/fat16.c ****         buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 896:SYSTEM/fat16.c ****         buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 897:SYSTEM/fat16.c ****         if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
 898:SYSTEM/fat16.c ****             return 0;
 899:SYSTEM/fat16.c ****     
 900:SYSTEM/fat16.c ****         /* free remaining clusters */
 901:SYSTEM/fat16.c ****         if(cluster_num_next)
 902:SYSTEM/fat16.c ****             return fat16_free_clusters(fs, cluster_num_next);
 903:SYSTEM/fat16.c ****         else
 904:SYSTEM/fat16.c ****             return 1;
 905:SYSTEM/fat16.c ****     #else
 906:SYSTEM/fat16.c ****         return 0;
 907:SYSTEM/fat16.c ****     #endif
 908:SYSTEM/fat16.c **** }
 909:SYSTEM/fat16.c **** 
 910:SYSTEM/fat16.c **** /**
 911:SYSTEM/fat16.c ****  * \ingroup fat16_file
 912:SYSTEM/fat16.c ****  * Opens a file on a FAT16 filesystem.
 913:SYSTEM/fat16.c ****  *
 914:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which the file to open lies.
 915:SYSTEM/fat16.c ****  * \param[in] dir_entry The directory entry of the file to open.
 916:SYSTEM/fat16.c ****  * \returns The file handle, or 0 on failure.
 917:SYSTEM/fat16.c ****  * \see fat16_close_file
 918:SYSTEM/fat16.c ****  */
 919:SYSTEM/fat16.c **** struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_
 920:SYSTEM/fat16.c **** {
 921:SYSTEM/fat16.c ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
 922:SYSTEM/fat16.c ****         return 0;
 923:SYSTEM/fat16.c **** 
 924:SYSTEM/fat16.c ****     struct fat16_file_struct* fd = malloc(sizeof(*fd));
 925:SYSTEM/fat16.c ****     if(!fd)
 926:SYSTEM/fat16.c ****         return 0;
 927:SYSTEM/fat16.c **** 
 928:SYSTEM/fat16.c ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 929:SYSTEM/fat16.c ****     fd->fs = fs;
 930:SYSTEM/fat16.c ****     fd->pos = 0;
 931:SYSTEM/fat16.c ****     fd->pos_cluster = dir_entry->cluster;
 932:SYSTEM/fat16.c **** 
 933:SYSTEM/fat16.c ****     return fd;
 934:SYSTEM/fat16.c **** }
 935:SYSTEM/fat16.c **** 
 936:SYSTEM/fat16.c **** /**
 937:SYSTEM/fat16.c ****  * \ingroup fat16_file
 938:SYSTEM/fat16.c ****  * Closes a file.
 939:SYSTEM/fat16.c ****  *
 940:SYSTEM/fat16.c ****  * \param[in] fd The file handle of the file to close.
 941:SYSTEM/fat16.c ****  * \see fat16_open_file
 942:SYSTEM/fat16.c ****  */
 943:SYSTEM/fat16.c **** void fat16_close_file(struct fat16_file_struct* fd)
 944:SYSTEM/fat16.c **** {
 945:SYSTEM/fat16.c ****     if(fd)
 946:SYSTEM/fat16.c ****         free(fd);
 947:SYSTEM/fat16.c **** }
 948:SYSTEM/fat16.c **** 
 949:SYSTEM/fat16.c **** /**
 950:SYSTEM/fat16.c ****  * \ingroup fat16_file
 951:SYSTEM/fat16.c ****  * Reads data from a file.
 952:SYSTEM/fat16.c ****  *
 953:SYSTEM/fat16.c ****  * The data requested is read from the current file location.
 954:SYSTEM/fat16.c ****  *
 955:SYSTEM/fat16.c ****  * \param[in] fd The file handle of the file from which to read.
 956:SYSTEM/fat16.c ****  * \param[out] buffer The buffer into which to write.
 957:SYSTEM/fat16.c ****  * \param[in] buffer_len The amount of data to read.
 958:SYSTEM/fat16.c ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 959:SYSTEM/fat16.c ****  * \see fat16_write_file
 960:SYSTEM/fat16.c ****  */
 961:SYSTEM/fat16.c **** int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
 962:SYSTEM/fat16.c **** {
 627              		.loc 1 962 0
 628              		@ Function supports interworking.
 629              		@ args = 0, pretend = 0, frame = 0
 630              		@ frame_needed = 0, uses_anonymous_args = 0
 631              	.LVL65:
 963:SYSTEM/fat16.c ****     /* check arguments */
 964:SYSTEM/fat16.c ****     if(!fd || !buffer || buffer_len < 1)
 632              		.loc 1 964 0
 633 04d8 000050E3 		cmp	r0, #0
 634 04dc 00005113 		cmpne	r1, #0
 635              		.loc 1 962 0
 636 04e0 F84F2DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 637              	.LCFI5:
 638              		.loc 1 964 0
 639 04e4 0190A0E1 		mov	r9, r1
 640 04e8 0040A0E1 		mov	r4, r0
 641              		.loc 1 962 0
 642 04ec 0260A0E1 		mov	r6, r2
 643              		.loc 1 964 0
 644 04f0 5700000A 		beq	.L58
 645              	.LVL66:
 646 04f4 000052E3 		cmp	r2, #0
 647 04f8 5500000A 		beq	.L58
 648              	.LVL67:
 965:SYSTEM/fat16.c ****         return -1;
 966:SYSTEM/fat16.c **** 
 967:SYSTEM/fat16.c ****     /* determine number of bytes to read */
 968:SYSTEM/fat16.c ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
 649              		.loc 1 968 0
 650 04fc 307090E5 		ldr	r7, [r0, #48]
 651              	.LVL68:
 652 0500 283090E5 		ldr	r3, [r0, #40]
 653 0504 072082E0 		add	r2, r2, r7
 654              	.LVL69:
 655 0508 030052E1 		cmp	r2, r3
 656 050c 0300009A 		bls	.L59
 657              	.LVL70:
 969:SYSTEM/fat16.c ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 658              		.loc 1 969 0
 659 0510 036067E0 		rsb	r6, r7, r3
 660              	.LVL71:
 661 0514 0668A0E1 		mov	r6, r6, asl #16
 970:SYSTEM/fat16.c ****     if(buffer_len == 0)
 662              		.loc 1 970 0
 663 0518 2668B0E1 		movs	r6, r6, lsr #16
 664              	.LVL72:
 665 051c 4E00000A 		beq	.L60
 666              	.L59:
 971:SYSTEM/fat16.c ****         return 0;
 972:SYSTEM/fat16.c **** 
 973:SYSTEM/fat16.c ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 974:SYSTEM/fat16.c ****     uint16_t cluster_num = fd->pos_cluster;
 667              		.loc 1 974 0
 668 0520 B453D4E1 		ldrh	r5, [r4, #52]
 669              	.LVL73:
 670              		.loc 1 973 0
 671 0524 003094E5 		ldr	r3, [r4, #0]
 975:SYSTEM/fat16.c ****     uint16_t buffer_left = buffer_len;
 976:SYSTEM/fat16.c ****     uint16_t first_cluster_offset = fd->pos % cluster_size;
 977:SYSTEM/fat16.c **** 
 978:SYSTEM/fat16.c ****     /* find cluster in which to start reading */
 979:SYSTEM/fat16.c ****     if(!cluster_num)
 672              		.loc 1 979 0
 673 0528 000055E3 		cmp	r5, #0
 674              		.loc 1 973 0
 675 052c B281D3E1 		ldrh	r8, [r3, #18]
 676              	.LVL74:
 677              		.loc 1 979 0
 678 0530 1200001A 		bne	.L61
 679              	.LVL75:
 980:SYSTEM/fat16.c ****     {
 981:SYSTEM/fat16.c ****         cluster_num = fd->dir_entry.cluster;
 680              		.loc 1 981 0
 681 0534 B652D4E1 		ldrh	r5, [r4, #38]
 682              	.LVL76:
 982:SYSTEM/fat16.c **** 
 983:SYSTEM/fat16.c ****         if(!cluster_num)
 683              		.loc 1 983 0
 684 0538 000055E3 		cmp	r5, #0
 685 053c 0200001A 		bne	.L62
 984:SYSTEM/fat16.c ****         {
 985:SYSTEM/fat16.c ****             if(!fd->pos)
 686              		.loc 1 985 0
 687 0540 000057E3 		cmp	r7, #0
 688 0544 4400000A 		beq	.L60
 689 0548 410000EA 		b	.L58
 690              	.L62:
 986:SYSTEM/fat16.c ****                 return 0;
 987:SYSTEM/fat16.c ****             else
 988:SYSTEM/fat16.c ****                 return -1;
 989:SYSTEM/fat16.c ****         }
 990:SYSTEM/fat16.c **** 
 991:SYSTEM/fat16.c ****         if(fd->pos)
 691              		.loc 1 991 0
 692 054c 000057E3 		cmp	r7, #0
 693 0550 07A0A011 		movne	sl, r7
 694              	.LBB23:
 992:SYSTEM/fat16.c ****         {
 993:SYSTEM/fat16.c ****             uint32_t pos = fd->pos;
 994:SYSTEM/fat16.c ****             while(pos >= cluster_size)
 995:SYSTEM/fat16.c ****             {
 996:SYSTEM/fat16.c ****                 pos -= cluster_size;
 997:SYSTEM/fat16.c ****                 cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
 998:SYSTEM/fat16.c ****                 if(!cluster_num)
 695              		.loc 1 998 0
 696 0554 00B06812 		rsbne	fp, r8, #0
 697              	.LBE23:
 698              		.loc 1 991 0
 699 0558 0500001A 		bne	.L63
 700              	.LVL77:
 701 055c 070000EA 		b	.L61
 702              	.LVL78:
 703              	.L64:
 704              	.LBB24:
 705              		.loc 1 997 0
 706 0560 000094E5 		ldr	r0, [r4, #0]
 707 0564 2DFFFFEB 		bl	fat16_get_next_cluster
 708              		.loc 1 998 0
 709 0568 005050E2 		subs	r5, r0, #0
 710              	.LVL79:
 711 056c 3800000A 		beq	.L58
 712 0570 0BA08AE0 		add	sl, sl, fp
 713              	.LVL80:
 714              	.L63:
 715              		.loc 1 994 0
 716 0574 08005AE1 		cmp	sl, r8
 717              		.loc 1 997 0
 718 0578 0510A0E1 		mov	r1, r5
 719              		.loc 1 994 0
 720 057c F7FFFF2A 		bcs	.L64
 721              	.LVL81:
 722              	.L61:
 723              	.LBE24:
 724              		.loc 1 976 0
 725 0580 0700A0E1 		mov	r0, r7
 726 0584 0810A0E1 		mov	r1, r8
 727 0588 FEFFFFEB 		bl	__aeabi_uidivmod
 728 058c 0118A0E1 		mov	r1, r1, asl #16
 729 0590 21B8A0E1 		mov	fp, r1, lsr #16
 730              	.LVL82:
 731 0594 0670A0E1 		mov	r7, r6
 732              	.LVL83:
 733              	.L70:
 734              	.LBB25:
 999:SYSTEM/fat16.c ****                     return -1;
1000:SYSTEM/fat16.c ****             }
1001:SYSTEM/fat16.c ****         }
1002:SYSTEM/fat16.c ****     }
1003:SYSTEM/fat16.c **** 
1004:SYSTEM/fat16.c ****     /* read data */
1005:SYSTEM/fat16.c ****     do
1006:SYSTEM/fat16.c ****     {
1007:SYSTEM/fat16.c ****         /* calculate data size to copy from cluster */
1008:SYSTEM/fat16.c ****         uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1009:SYSTEM/fat16.c ****         (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1010:SYSTEM/fat16.c ****         uint16_t copy_length = cluster_size - first_cluster_offset;
 735              		.loc 1 1010 0
 736 0598 08A06BE0 		rsb	sl, fp, r8
 737              	.LVL84:
 738              		.loc 1 1008 0
 739 059c 003094E5 		ldr	r3, [r4, #0]
 740              		.loc 1 1010 0
 741 05a0 0AA8A0E1 		mov	sl, sl, asl #16
 742 05a4 2AA8A0E1 		mov	sl, sl, lsr #16
 743              	.LVL85:
1011:SYSTEM/fat16.c ****         if(copy_length > buffer_left)
1012:SYSTEM/fat16.c ****             copy_length = buffer_left;
1013:SYSTEM/fat16.c **** 
1014:SYSTEM/fat16.c ****         /* read data */
1015:SYSTEM/fat16.c ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
 744              		.loc 1 1015 0
 745 05a8 182093E5 		ldr	r2, [r3, #24]
 746              		.loc 1 1010 0
 747 05ac 07005AE1 		cmp	sl, r7
 748 05b0 07A0A021 		movcs	sl, r7
 749              	.LVL86:
 750 05b4 0AA8A0E1 		mov	sl, sl, asl #16
 751 05b8 2AA8A0E1 		mov	sl, sl, lsr #16
 752              	.LVL87:
 753              		.loc 1 1015 0
 754 05bc 02208BE0 		add	r2, fp, r2
 755 05c0 020045E2 		sub	r0, r5, #2
 756 05c4 982020E0 		mla	r0, r8, r0, r2
 757 05c8 003093E5 		ldr	r3, [r3, #0]
 758 05cc 0A20A0E1 		mov	r2, sl
 759 05d0 0910A0E1 		mov	r1, r9
 760 05d4 00C093E5 		ldr	ip, [r3, #0]
 761 05d8 0FE0A0E1 		mov	lr, pc
 762 05dc 1CFF2FE1 		bx	ip
1016:SYSTEM/fat16.c ****             return buffer_len - buffer_left;
1017:SYSTEM/fat16.c **** 
1018:SYSTEM/fat16.c ****         /* calculate new file position */
1019:SYSTEM/fat16.c ****         buffer += copy_length;
1020:SYSTEM/fat16.c ****         buffer_left -= copy_length;
 763              		.loc 1 1020 0
 764 05e0 07206AE0 		rsb	r2, sl, r7
 765              		.loc 1 1015 0
 766 05e4 000050E3 		cmp	r0, #0
1021:SYSTEM/fat16.c ****         fd->pos += copy_length;
1022:SYSTEM/fat16.c **** 
1023:SYSTEM/fat16.c ****         if(first_cluster_offset + copy_length >= cluster_size)
 767              		.loc 1 1023 0
 768 05e8 0B308AE0 		add	r3, sl, fp
 769              		.loc 1 1020 0
 770 05ec 0228A0E1 		mov	r2, r2, asl #16
 771              		.loc 1 1015 0
 772              		.loc 1 1016 0
 773 05f0 06606700 		rsbeq	r6, r7, r6
 774              	.LVL88:
 775 05f4 0668A001 		moveq	r6, r6, asl #16
 776 05f8 0D00000A 		beq	.L72
 777              	.LVL89:
 778              	.L65:
 779              		.loc 1 1021 0
 780 05fc 301094E5 		ldr	r1, [r4, #48]
 781              		.loc 1 1023 0
 782 0600 080053E1 		cmp	r3, r8
 783              		.loc 1 1021 0
 784 0604 0A3081E0 		add	r3, r1, sl
 785 0608 303084E5 		str	r3, [r4, #48]
 786              		.loc 1 1020 0
 787 060c 2278A0E1 		mov	r7, r2, lsr #16
 788              	.LVL90:
 789              		.loc 1 1023 0
 790 0610 0A0000BA 		blt	.L67
1024:SYSTEM/fat16.c ****         {
1025:SYSTEM/fat16.c ****             /* we are on a cluster boundary, so get the next cluster */
1026:SYSTEM/fat16.c ****             if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
 791              		.loc 1 1026 0
 792 0614 0510A0E1 		mov	r1, r5
 793 0618 000094E5 		ldr	r0, [r4, #0]
 794 061c FFFEFFEB 		bl	fat16_get_next_cluster
 795 0620 005050E2 		subs	r5, r0, #0
 796              	.LVL91:
 797 0624 0400001A 		bne	.L68
1027:SYSTEM/fat16.c ****             {
1028:SYSTEM/fat16.c ****                 first_cluster_offset = 0;
1029:SYSTEM/fat16.c ****             }
1030:SYSTEM/fat16.c ****             else
1031:SYSTEM/fat16.c ****             {
1032:SYSTEM/fat16.c ****                 fd->pos_cluster = 0;
1033:SYSTEM/fat16.c ****                 return buffer_len - buffer_left;
 798              		.loc 1 1033 0
 799 0628 066067E0 		rsb	r6, r7, r6
 800              	.LVL92:
 801              		.loc 1 1032 0
 802 062c B453C4E1 		strh	r5, [r4, #52]	@ movhi
 803              		.loc 1 1033 0
 804 0630 0668A0E1 		mov	r6, r6, asl #16
 805              	.L72:
 806 0634 2668A0E1 		mov	r6, r6, lsr #16
 807 0638 080000EA 		b	.L66
 808              	.LVL93:
 809              	.L68:
 810 063c 00B0A0E3 		mov	fp, #0
 811              	.LVL94:
 812              	.L67:
 813              	.LBE25:
1034:SYSTEM/fat16.c ****             }
1035:SYSTEM/fat16.c ****         }
1036:SYSTEM/fat16.c **** 
1037:SYSTEM/fat16.c ****         fd->pos_cluster = cluster_num;
1038:SYSTEM/fat16.c **** 
1039:SYSTEM/fat16.c ****     }
1040:SYSTEM/fat16.c ****     while(buffer_left > 0); /* check if we are done */
 814              		.loc 1 1040 0
 815 0640 000057E3 		cmp	r7, #0
 816              	.LBB26:
 817              		.loc 1 1037 0
 818 0644 B453C4E1 		strh	r5, [r4, #52]	@ movhi
 819              	.LBE26:
 820              		.loc 1 1040 0
 821 0648 0400000A 		beq	.L66
 822              	.LBB27:
 823              		.loc 1 1019 0
 824 064c 0A9089E0 		add	r9, r9, sl
 825 0650 D0FFFFEA 		b	.L70
 826              	.LVL95:
 827              	.L58:
 828              	.LBE27:
1041:SYSTEM/fat16.c **** 
1042:SYSTEM/fat16.c ****     return buffer_len;
 829              		.loc 1 1042 0
 830 0654 14609FE5 		ldr	r6, .L73
 831              	.LVL96:
 832 0658 000000EA 		b	.L66
 833              	.LVL97:
 834              	.L60:
 835 065c 0060A0E3 		mov	r6, #0
 836              	.LVL98:
 837              	.L66:
 838 0660 0668A0E1 		mov	r6, r6, asl #16
 839              	.LVL99:
1043:SYSTEM/fat16.c **** }
 840              		.loc 1 1043 0
 841 0664 4608A0E1 		mov	r0, r6, asr #16
 842 0668 F84FBDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 843 066c 1EFF2FE1 		bx	lr
 844              	.L74:
 845              		.align	2
 846              	.L73:
 847 0670 FFFF0000 		.word	65535
 848              	.LFE15:
 850              		.align	2
 851              		.global	fat16_reset_dir
 853              	fat16_reset_dir:
 854              	.LFB22:
1044:SYSTEM/fat16.c **** 
1045:SYSTEM/fat16.c **** /**
1046:SYSTEM/fat16.c ****  * \ingroup fat16_file
1047:SYSTEM/fat16.c ****  * Writes data to a file.
1048:SYSTEM/fat16.c ****  *
1049:SYSTEM/fat16.c ****  * The data is written to the current file location.
1050:SYSTEM/fat16.c ****  *
1051:SYSTEM/fat16.c ****  * \param[in] fd The file handle of the file to which to write.
1052:SYSTEM/fat16.c ****  * \param[in] buffer The buffer from which to read the data to be written.
1053:SYSTEM/fat16.c ****  * \param[in] buffer_len The amount of data to write.
1054:SYSTEM/fat16.c ****  * \returns The number of bytes written, 0 on disk full, or -1 on failure.
1055:SYSTEM/fat16.c ****  * \see fat16_read_file
1056:SYSTEM/fat16.c ****  */
1057:SYSTEM/fat16.c **** int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
1058:SYSTEM/fat16.c **** {
1059:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
1060:SYSTEM/fat16.c ****         /* check arguments */
1061:SYSTEM/fat16.c ****         if(!fd || !buffer || buffer_len < 1)
1062:SYSTEM/fat16.c ****             return -1;
1063:SYSTEM/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1064:SYSTEM/fat16.c ****             return -1;
1065:SYSTEM/fat16.c ****     
1066:SYSTEM/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1067:SYSTEM/fat16.c ****         uint16_t cluster_num = fd->pos_cluster;
1068:SYSTEM/fat16.c ****         uint16_t buffer_left = buffer_len;
1069:SYSTEM/fat16.c ****         uint16_t first_cluster_offset = fd->pos % cluster_size;
1070:SYSTEM/fat16.c ****     
1071:SYSTEM/fat16.c ****         /* find cluster in which to start writing */
1072:SYSTEM/fat16.c ****         if(!cluster_num)
1073:SYSTEM/fat16.c ****         {
1074:SYSTEM/fat16.c ****             cluster_num = fd->dir_entry.cluster;
1075:SYSTEM/fat16.c ****     
1076:SYSTEM/fat16.c ****             if(!cluster_num)
1077:SYSTEM/fat16.c ****             {
1078:SYSTEM/fat16.c ****                 if(!fd->pos)
1079:SYSTEM/fat16.c ****                 {
1080:SYSTEM/fat16.c ****                     /* empty file */
1081:SYSTEM/fat16.c ****                     fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
1082:SYSTEM/fat16.c ****                     if(!cluster_num)
1083:SYSTEM/fat16.c ****                         return -1;
1084:SYSTEM/fat16.c ****                 }
1085:SYSTEM/fat16.c ****                 else
1086:SYSTEM/fat16.c ****                 {
1087:SYSTEM/fat16.c ****                     return -1;
1088:SYSTEM/fat16.c ****                 }
1089:SYSTEM/fat16.c ****             }
1090:SYSTEM/fat16.c ****     
1091:SYSTEM/fat16.c ****             if(fd->pos)
1092:SYSTEM/fat16.c ****             {
1093:SYSTEM/fat16.c ****                 uint32_t pos = fd->pos;
1094:SYSTEM/fat16.c ****                 uint16_t cluster_num_next;
1095:SYSTEM/fat16.c ****                 while(pos >= cluster_size)
1096:SYSTEM/fat16.c ****                 {
1097:SYSTEM/fat16.c ****                     pos -= cluster_size;
1098:SYSTEM/fat16.c ****                     cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1099:SYSTEM/fat16.c ****                     if(!cluster_num_next && pos == 0)
1100:SYSTEM/fat16.c ****         /* the file exactly ends on a cluster boundary, and we append to it */
1101:SYSTEM/fat16.c ****                         cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1102:SYSTEM/fat16.c ****                     if(!cluster_num_next)
1103:SYSTEM/fat16.c ****                         return -1;
1104:SYSTEM/fat16.c ****     
1105:SYSTEM/fat16.c ****                     cluster_num = cluster_num_next;
1106:SYSTEM/fat16.c ****                 }
1107:SYSTEM/fat16.c ****             }
1108:SYSTEM/fat16.c ****         }
1109:SYSTEM/fat16.c ****     
1110:SYSTEM/fat16.c ****         /* write data */
1111:SYSTEM/fat16.c ****         do
1112:SYSTEM/fat16.c ****         {
1113:SYSTEM/fat16.c ****             /* calculate data size to write to cluster */
1114:SYSTEM/fat16.c ****             uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1115:SYSTEM/fat16.c ****             (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1116:SYSTEM/fat16.c ****             uint16_t write_length = cluster_size - first_cluster_offset;
1117:SYSTEM/fat16.c ****             if(write_length > buffer_left)
1118:SYSTEM/fat16.c ****                 write_length = buffer_left;
1119:SYSTEM/fat16.c ****     
1120:SYSTEM/fat16.c ****             /* write data which fits into the current cluster */
1121:SYSTEM/fat16.c ****             if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1122:SYSTEM/fat16.c ****                 break;
1123:SYSTEM/fat16.c ****     
1124:SYSTEM/fat16.c ****             /* calculate new file position */
1125:SYSTEM/fat16.c ****             buffer += write_length;
1126:SYSTEM/fat16.c ****             buffer_left -= write_length;
1127:SYSTEM/fat16.c ****             fd->pos += write_length;
1128:SYSTEM/fat16.c ****     
1129:SYSTEM/fat16.c ****             if(first_cluster_offset + write_length >= cluster_size)
1130:SYSTEM/fat16.c ****             {
1131:SYSTEM/fat16.c ****                 /* we are on a cluster boundary, so get the next cluster */
1132:SYSTEM/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1133:SYSTEM/fat16.c ****                 if(!cluster_num_next && buffer_left > 0)
1134:SYSTEM/fat16.c ****         /* we reached the last cluster, append a new one */
1135:SYSTEM/fat16.c ****                     cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1136:SYSTEM/fat16.c ****                 if(!cluster_num_next)
1137:SYSTEM/fat16.c ****                 {
1138:SYSTEM/fat16.c ****                     fd->pos_cluster = 0;
1139:SYSTEM/fat16.c ****                     break;
1140:SYSTEM/fat16.c ****                 }
1141:SYSTEM/fat16.c ****     
1142:SYSTEM/fat16.c ****                 cluster_num = cluster_num_next;
1143:SYSTEM/fat16.c ****                 first_cluster_offset = 0;
1144:SYSTEM/fat16.c ****             }
1145:SYSTEM/fat16.c ****     
1146:SYSTEM/fat16.c ****             fd->pos_cluster = cluster_num;
1147:SYSTEM/fat16.c ****     
1148:SYSTEM/fat16.c ****         }
1149:SYSTEM/fat16.c ****         while(buffer_left > 0); /* check if we are done */
1150:SYSTEM/fat16.c ****     
1151:SYSTEM/fat16.c ****         /* update directory entry */
1152:SYSTEM/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1153:SYSTEM/fat16.c ****         {
1154:SYSTEM/fat16.c ****             uint32_t size_old = fd->dir_entry.file_size;
1155:SYSTEM/fat16.c ****     
1156:SYSTEM/fat16.c ****             /* update file size */
1157:SYSTEM/fat16.c ****             fd->dir_entry.file_size = fd->pos;
1158:SYSTEM/fat16.c ****             /* write directory entry */
1159:SYSTEM/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1160:SYSTEM/fat16.c ****             {
1161:SYSTEM/fat16.c ****                 /* We do not return an error here since we actually wrote
1162:SYSTEM/fat16.c ****                                                              * some data to disk. So we calculate t
1163:SYSTEM/fat16.c ****                                                              * we wrote to disk and which lies with
1164:SYSTEM/fat16.c ****                                                              */
1165:SYSTEM/fat16.c ****                 buffer_left = fd->pos - size_old;
1166:SYSTEM/fat16.c ****                 fd->pos = size_old;
1167:SYSTEM/fat16.c ****             }
1168:SYSTEM/fat16.c ****         }
1169:SYSTEM/fat16.c ****     
1170:SYSTEM/fat16.c ****         return buffer_len - buffer_left;
1171:SYSTEM/fat16.c ****     
1172:SYSTEM/fat16.c ****     #else
1173:SYSTEM/fat16.c ****         return -1;
1174:SYSTEM/fat16.c ****     #endif
1175:SYSTEM/fat16.c **** }
1176:SYSTEM/fat16.c **** 
1177:SYSTEM/fat16.c **** /**
1178:SYSTEM/fat16.c ****  * \ingroup fat16_file
1179:SYSTEM/fat16.c ****  * Repositions the read/write file offset.
1180:SYSTEM/fat16.c ****  *
1181:SYSTEM/fat16.c ****  * Changes the file offset where the next call to fat16_read_file()
1182:SYSTEM/fat16.c ****  * or fat16_write_file() starts reading/writing.
1183:SYSTEM/fat16.c ****  *
1184:SYSTEM/fat16.c ****  * If the new offset is beyond the end of the file, fat16_resize_file()
1185:SYSTEM/fat16.c ****  * is implicitly called, i.e. the file is expanded.
1186:SYSTEM/fat16.c ****  *
1187:SYSTEM/fat16.c ****  * The new offset can be given in different ways determined by
1188:SYSTEM/fat16.c ****  * the \c whence parameter:
1189:SYSTEM/fat16.c ****  * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
1190:SYSTEM/fat16.c ****  * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
1191:SYSTEM/fat16.c ****  * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
1192:SYSTEM/fat16.c ****  *
1193:SYSTEM/fat16.c ****  * The resulting absolute offset is written to the location the \c offset
1194:SYSTEM/fat16.c ****  * parameter points to.
1195:SYSTEM/fat16.c ****  *
1196:SYSTEM/fat16.c ****  * \param[in] fd The file decriptor of the file on which to seek.
1197:SYSTEM/fat16.c ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1198:SYSTEM/fat16.c ****  *                   parameter. The function writes the new absolute offset
1199:SYSTEM/fat16.c ****  *                   to this location before it returns.
1200:SYSTEM/fat16.c ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1201:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1202:SYSTEM/fat16.c ****  */
1203:SYSTEM/fat16.c **** uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
1204:SYSTEM/fat16.c **** {
1205:SYSTEM/fat16.c ****     if(!fd || !offset)
1206:SYSTEM/fat16.c ****         return 0;
1207:SYSTEM/fat16.c **** 
1208:SYSTEM/fat16.c ****     uint32_t new_pos = fd->pos;
1209:SYSTEM/fat16.c ****     switch(whence)
1210:SYSTEM/fat16.c ****     {
1211:SYSTEM/fat16.c ****         case FAT16_SEEK_SET:
1212:SYSTEM/fat16.c ****             new_pos = *offset;
1213:SYSTEM/fat16.c ****             break;
1214:SYSTEM/fat16.c ****         case FAT16_SEEK_CUR:
1215:SYSTEM/fat16.c ****             new_pos += *offset;
1216:SYSTEM/fat16.c ****             break;
1217:SYSTEM/fat16.c ****         case FAT16_SEEK_END:
1218:SYSTEM/fat16.c ****             new_pos = fd->dir_entry.file_size + *offset;
1219:SYSTEM/fat16.c ****             break;
1220:SYSTEM/fat16.c ****         default:
1221:SYSTEM/fat16.c ****             return 0;
1222:SYSTEM/fat16.c ****     }
1223:SYSTEM/fat16.c **** 
1224:SYSTEM/fat16.c ****     if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
1225:SYSTEM/fat16.c ****         return 0;
1226:SYSTEM/fat16.c **** 
1227:SYSTEM/fat16.c ****     fd->pos = new_pos;
1228:SYSTEM/fat16.c ****     fd->pos_cluster = 0;
1229:SYSTEM/fat16.c **** 
1230:SYSTEM/fat16.c ****     *offset = new_pos;
1231:SYSTEM/fat16.c ****     return 1;
1232:SYSTEM/fat16.c **** }
1233:SYSTEM/fat16.c **** 
1234:SYSTEM/fat16.c **** /**
1235:SYSTEM/fat16.c ****  * \ingroup fat16_file
1236:SYSTEM/fat16.c ****  * Resizes a file to have a specific size.
1237:SYSTEM/fat16.c ****  *
1238:SYSTEM/fat16.c ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1239:SYSTEM/fat16.c ****  * exactly the specified size.
1240:SYSTEM/fat16.c ****  *
1241:SYSTEM/fat16.c ****  * If the file is truncated, all bytes having an equal or larger offset
1242:SYSTEM/fat16.c ****  * than the given size are lost. If the file is expanded, the additional
1243:SYSTEM/fat16.c ****  * bytes are allocated.
1244:SYSTEM/fat16.c ****  *
1245:SYSTEM/fat16.c ****  * \note Please be aware that this function just allocates or deallocates disk
1246:SYSTEM/fat16.c ****  * space, it does not explicitely clear it. To avoid data leakage, this
1247:SYSTEM/fat16.c ****  * must be done manually.
1248:SYSTEM/fat16.c ****  *
1249:SYSTEM/fat16.c ****  * \param[in] fd The file decriptor of the file which to resize.
1250:SYSTEM/fat16.c ****  * \param[in] size The new size of the file.
1251:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1252:SYSTEM/fat16.c ****  */
1253:SYSTEM/fat16.c **** uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
1254:SYSTEM/fat16.c **** {
1255:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
1256:SYSTEM/fat16.c ****         if(!fd)
1257:SYSTEM/fat16.c ****             return 0;
1258:SYSTEM/fat16.c ****     
1259:SYSTEM/fat16.c ****         uint16_t cluster_num = fd->dir_entry.cluster;
1260:SYSTEM/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1261:SYSTEM/fat16.c ****         uint32_t size_new = size;
1262:SYSTEM/fat16.c ****     
1263:SYSTEM/fat16.c ****         do
1264:SYSTEM/fat16.c ****         {
1265:SYSTEM/fat16.c ****             if(cluster_num == 0 && size_new == 0)
1266:SYSTEM/fat16.c ****         /* the file stays empty */
1267:SYSTEM/fat16.c ****                 break;
1268:SYSTEM/fat16.c ****     
1269:SYSTEM/fat16.c ****             /* seek to the next cluster as long as we need the space */
1270:SYSTEM/fat16.c ****             while(size_new > cluster_size)
1271:SYSTEM/fat16.c ****             {
1272:SYSTEM/fat16.c ****                 /* get next cluster of file */
1273:SYSTEM/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1274:SYSTEM/fat16.c ****                 if(cluster_num_next)
1275:SYSTEM/fat16.c ****                 {
1276:SYSTEM/fat16.c ****                     cluster_num = cluster_num_next;
1277:SYSTEM/fat16.c ****                     size_new -= cluster_size;
1278:SYSTEM/fat16.c ****                 }
1279:SYSTEM/fat16.c ****                 else
1280:SYSTEM/fat16.c ****                 {
1281:SYSTEM/fat16.c ****                     break;
1282:SYSTEM/fat16.c ****                 }
1283:SYSTEM/fat16.c ****             }
1284:SYSTEM/fat16.c ****     
1285:SYSTEM/fat16.c ****             if(size_new > cluster_size || cluster_num == 0)
1286:SYSTEM/fat16.c ****             {
1287:SYSTEM/fat16.c ****                 /* Allocate new cluster chain and append
1288:SYSTEM/fat16.c ****                                                              * it to the existing one, if available
1289:SYSTEM/fat16.c ****                                                              */
1290:SYSTEM/fat16.c ****                 uint16_t cluster_count = size_new / cluster_size;
1291:SYSTEM/fat16.c ****                 if((uint32_t) cluster_count * cluster_size < size_new)
1292:SYSTEM/fat16.c ****                     ++cluster_count;
1293:SYSTEM/fat16.c ****                 uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_cou
1294:SYSTEM/fat16.c ****                 if(!cluster_new_chain)
1295:SYSTEM/fat16.c ****                     return 0;
1296:SYSTEM/fat16.c ****     
1297:SYSTEM/fat16.c ****                 if(!cluster_num)
1298:SYSTEM/fat16.c ****                 {
1299:SYSTEM/fat16.c ****                     cluster_num = cluster_new_chain;
1300:SYSTEM/fat16.c ****                     fd->dir_entry.cluster = cluster_num;
1301:SYSTEM/fat16.c ****                 }
1302:SYSTEM/fat16.c ****             }
1303:SYSTEM/fat16.c ****     
1304:SYSTEM/fat16.c ****             /* write new directory entry */
1305:SYSTEM/fat16.c ****             fd->dir_entry.file_size = size;
1306:SYSTEM/fat16.c ****             if(size == 0)
1307:SYSTEM/fat16.c ****                 fd->dir_entry.cluster = 0;
1308:SYSTEM/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1309:SYSTEM/fat16.c ****                 return 0;
1310:SYSTEM/fat16.c ****     
1311:SYSTEM/fat16.c ****             if(size == 0)
1312:SYSTEM/fat16.c ****             {
1313:SYSTEM/fat16.c ****                 /* free all clusters of file */
1314:SYSTEM/fat16.c ****                 fat16_free_clusters(fd->fs, cluster_num);
1315:SYSTEM/fat16.c ****             }
1316:SYSTEM/fat16.c ****             else if(size_new <= cluster_size)
1317:SYSTEM/fat16.c ****             {
1318:SYSTEM/fat16.c ****                 /* free all clusters no longer needed */
1319:SYSTEM/fat16.c ****                 fat16_terminate_clusters(fd->fs, cluster_num);
1320:SYSTEM/fat16.c ****             }
1321:SYSTEM/fat16.c ****     
1322:SYSTEM/fat16.c ****         }
1323:SYSTEM/fat16.c ****         while(0);
1324:SYSTEM/fat16.c ****     
1325:SYSTEM/fat16.c ****         /* correct file position */
1326:SYSTEM/fat16.c ****         if(size < fd->pos)
1327:SYSTEM/fat16.c ****         {
1328:SYSTEM/fat16.c ****             fd->pos = size;
1329:SYSTEM/fat16.c ****             fd->pos_cluster = 0;
1330:SYSTEM/fat16.c ****         }
1331:SYSTEM/fat16.c ****     
1332:SYSTEM/fat16.c ****         return 1;
1333:SYSTEM/fat16.c ****     #else
1334:SYSTEM/fat16.c ****         return 0;
1335:SYSTEM/fat16.c ****     #endif
1336:SYSTEM/fat16.c **** }
1337:SYSTEM/fat16.c **** 
1338:SYSTEM/fat16.c **** /**
1339:SYSTEM/fat16.c ****  * \ingroup fat16_dir
1340:SYSTEM/fat16.c ****  * Opens a directory.
1341:SYSTEM/fat16.c ****  *
1342:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which the directory to open resides.
1343:SYSTEM/fat16.c ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1344:SYSTEM/fat16.c ****  * \returns An opaque directory descriptor on success, 0 on failure.
1345:SYSTEM/fat16.c ****  * \see fat16_close_dir
1346:SYSTEM/fat16.c ****  */
1347:SYSTEM/fat16.c **** struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_st
1348:SYSTEM/fat16.c **** {
1349:SYSTEM/fat16.c ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
1350:SYSTEM/fat16.c ****         return 0;
1351:SYSTEM/fat16.c **** 
1352:SYSTEM/fat16.c ****     struct fat16_dir_struct* dd = malloc(sizeof(*dd));
1353:SYSTEM/fat16.c ****     if(!dd)
1354:SYSTEM/fat16.c ****         return 0;
1355:SYSTEM/fat16.c **** 
1356:SYSTEM/fat16.c ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1357:SYSTEM/fat16.c ****     dd->fs = fs;
1358:SYSTEM/fat16.c ****     dd->entry_next = 0;
1359:SYSTEM/fat16.c **** 
1360:SYSTEM/fat16.c ****     return dd;
1361:SYSTEM/fat16.c **** }
1362:SYSTEM/fat16.c **** 
1363:SYSTEM/fat16.c **** /**
1364:SYSTEM/fat16.c ****  * \ingroup fat16_dir
1365:SYSTEM/fat16.c ****  * Closes a directory descriptor.
1366:SYSTEM/fat16.c ****  *
1367:SYSTEM/fat16.c ****  * This function destroys a directory descriptor which was
1368:SYSTEM/fat16.c ****  * previously obtained by calling fat16_open_dir(). When this
1369:SYSTEM/fat16.c ****  * function returns, the given descriptor will be invalid.
1370:SYSTEM/fat16.c ****  *
1371:SYSTEM/fat16.c ****  * \param[in] dd The directory descriptor to close.
1372:SYSTEM/fat16.c ****  * \see fat16_open_dir
1373:SYSTEM/fat16.c ****  */
1374:SYSTEM/fat16.c **** void fat16_close_dir(struct fat16_dir_struct* dd)
1375:SYSTEM/fat16.c **** {
1376:SYSTEM/fat16.c ****     if(dd)
1377:SYSTEM/fat16.c ****         free(dd);
1378:SYSTEM/fat16.c **** }
1379:SYSTEM/fat16.c **** 
1380:SYSTEM/fat16.c **** /**
1381:SYSTEM/fat16.c ****  * \ingroup fat16_dir
1382:SYSTEM/fat16.c ****  * Reads the next directory entry contained within a parent directory.
1383:SYSTEM/fat16.c ****  *
1384:SYSTEM/fat16.c ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1385:SYSTEM/fat16.c ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1386:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1387:SYSTEM/fat16.c ****  * \see fat16_reset_dir
1388:SYSTEM/fat16.c ****  */
1389:SYSTEM/fat16.c **** uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
1390:SYSTEM/fat16.c **** {
1391:SYSTEM/fat16.c ****     if(!dd || !dir_entry)
1392:SYSTEM/fat16.c ****         return 0;
1393:SYSTEM/fat16.c **** 
1394:SYSTEM/fat16.c ****     if(dd->dir_entry.cluster == 0)
1395:SYSTEM/fat16.c ****     {
1396:SYSTEM/fat16.c ****         /* read entry from root directory */
1397:SYSTEM/fat16.c ****         if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
1398:SYSTEM/fat16.c ****         {
1399:SYSTEM/fat16.c ****             ++dd->entry_next;
1400:SYSTEM/fat16.c ****             return 1;
1401:SYSTEM/fat16.c ****         }
1402:SYSTEM/fat16.c ****     }
1403:SYSTEM/fat16.c ****     else
1404:SYSTEM/fat16.c ****     {
1405:SYSTEM/fat16.c ****         /* read entry from a subdirectory */
1406:SYSTEM/fat16.c ****         if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
1407:SYSTEM/fat16.c ****         {
1408:SYSTEM/fat16.c ****             ++dd->entry_next;
1409:SYSTEM/fat16.c ****             return 1;
1410:SYSTEM/fat16.c ****         }
1411:SYSTEM/fat16.c ****     }
1412:SYSTEM/fat16.c **** 
1413:SYSTEM/fat16.c ****     /* restart reading */
1414:SYSTEM/fat16.c ****     dd->entry_next = 0;
1415:SYSTEM/fat16.c **** 
1416:SYSTEM/fat16.c ****     return 0;
1417:SYSTEM/fat16.c **** }
1418:SYSTEM/fat16.c **** 
1419:SYSTEM/fat16.c **** /**
1420:SYSTEM/fat16.c ****  * \ingroup fat16_dir
1421:SYSTEM/fat16.c ****  * Resets a directory handle.
1422:SYSTEM/fat16.c ****  *
1423:SYSTEM/fat16.c ****  * Resets the directory handle such that reading restarts
1424:SYSTEM/fat16.c ****  * with the first directory entry.
1425:SYSTEM/fat16.c ****  *
1426:SYSTEM/fat16.c ****  * \param[in] dd The directory handle to reset.
1427:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1428:SYSTEM/fat16.c ****  * \see fat16_read_dir
1429:SYSTEM/fat16.c ****  */
1430:SYSTEM/fat16.c **** uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
1431:SYSTEM/fat16.c **** {
 855              		.loc 1 1431 0
 856              		@ Function supports interworking.
 857              		@ args = 0, pretend = 0, frame = 0
 858              		@ frame_needed = 0, uses_anonymous_args = 0
 859              		@ link register save eliminated.
 860              	.LVL100:
1432:SYSTEM/fat16.c ****     if(!dd)
 861              		.loc 1 1432 0
 862 0674 000050E3 		cmp	r0, #0
1433:SYSTEM/fat16.c ****         return 0;
1434:SYSTEM/fat16.c **** 
1435:SYSTEM/fat16.c ****     dd->entry_next = 0;
 863              		.loc 1 1435 0
 864 0678 0030A013 		movne	r3, #0	@ movhi
 865 067c B033C011 		strneh	r3, [r0, #48]	@ movhi
 866 0680 0100A013 		movne	r0, #1
 867              	.LVL101:
1436:SYSTEM/fat16.c ****     return 1;
1437:SYSTEM/fat16.c **** }
 868              		.loc 1 1437 0
 869 0684 1EFF2FE1 		bx	lr
 870              	.LFE22:
 872              		.align	2
 873              		.global	fat16_set_dir
 875              	fat16_set_dir:
 876              	.LFB23:
1438:SYSTEM/fat16.c **** 
1439:SYSTEM/fat16.c **** uint8_t fat16_set_dir(struct fat16_dir_struct* dd, uint16_t offset)
1440:SYSTEM/fat16.c **** {
 877              		.loc 1 1440 0
 878              		@ Function supports interworking.
 879              		@ args = 0, pretend = 0, frame = 0
 880              		@ frame_needed = 0, uses_anonymous_args = 0
 881              		@ link register save eliminated.
 882              	.LVL102:
1441:SYSTEM/fat16.c ****     if(!dd)
 883              		.loc 1 1441 0
 884 0688 000050E3 		cmp	r0, #0
1442:SYSTEM/fat16.c ****         return 0;
1443:SYSTEM/fat16.c **** 
1444:SYSTEM/fat16.c ****     dd->entry_next = offset;
 885              		.loc 1 1444 0
 886 068c B013C011 		strneh	r1, [r0, #48]	@ movhi
 887 0690 0100A013 		movne	r0, #1
 888              	.LVL103:
1445:SYSTEM/fat16.c ****     return 1;
1446:SYSTEM/fat16.c **** }
 889              		.loc 1 1446 0
 890 0694 1EFF2FE1 		bx	lr
 891              	.LFE23:
 893              		.align	2
 894              		.global	fat16_delete_file
 896              	fat16_delete_file:
 897              	.LFB26:
1447:SYSTEM/fat16.c **** 
1448:SYSTEM/fat16.c **** /**
1449:SYSTEM/fat16.c ****  * \ingroup fat16_fs
1450:SYSTEM/fat16.c ****  * Writes a directory entry to disk.
1451:SYSTEM/fat16.c ****  *
1452:SYSTEM/fat16.c ****  * \note The file name is not checked for invalid characters.
1453:SYSTEM/fat16.c ****  *
1454:SYSTEM/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1455:SYSTEM/fat16.c ****  * simple. The first eight characters are used for the filename.
1456:SYSTEM/fat16.c ****  * The extension, if any, is made up of the first three characters
1457:SYSTEM/fat16.c ****  * following the last dot within the long filename. If the
1458:SYSTEM/fat16.c ****  * filename (without the extension) is longer than eight characters,
1459:SYSTEM/fat16.c ****  * the lower byte of the cluster number replaces the last two
1460:SYSTEM/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1461:SYSTEM/fat16.c ****  * responsibility to avoid name clashes.
1462:SYSTEM/fat16.c ****  *
1463:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1464:SYSTEM/fat16.c ****  * \param[in] dir_entry The directory entry to write.
1465:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1466:SYSTEM/fat16.c ****  */
1467:SYSTEM/fat16.c **** uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct
1468:SYSTEM/fat16.c **** {
1469:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
1470:SYSTEM/fat16.c ****         if(!fs || !dir_entry)
1471:SYSTEM/fat16.c ****             return 0;
1472:SYSTEM/fat16.c ****     
1473:SYSTEM/fat16.c ****         device_write_t device_write = fs->partition->device_write;
1474:SYSTEM/fat16.c ****         uint32_t offset = dir_entry->entry_offset;
1475:SYSTEM/fat16.c ****         uint8_t name_len = strlen(dir_entry->long_name);
1476:SYSTEM/fat16.c ****         uint8_t lfn_entry_count = (name_len + 12) / 13;
1477:SYSTEM/fat16.c ****         uint8_t buffer[32];
1478:SYSTEM/fat16.c ****     
1479:SYSTEM/fat16.c ****         /* write 8.3 entry */
1480:SYSTEM/fat16.c ****     
1481:SYSTEM/fat16.c ****         /* generate 8.3 file name */
1482:SYSTEM/fat16.c ****         memset(&buffer[0], ' ', 11);
1483:SYSTEM/fat16.c ****         char* name_ext = strrchr(dir_entry->long_name, '.');
1484:SYSTEM/fat16.c ****         if(name_ext)
1485:SYSTEM/fat16.c ****         {
1486:SYSTEM/fat16.c ****             ++name_ext;
1487:SYSTEM/fat16.c ****     
1488:SYSTEM/fat16.c ****             uint8_t name_ext_len = strlen(name_ext);
1489:SYSTEM/fat16.c ****             name_len -= name_ext_len + 1;
1490:SYSTEM/fat16.c ****     
1491:SYSTEM/fat16.c ****             if(name_ext_len > 3)
1492:SYSTEM/fat16.c ****                 name_ext_len = 3;
1493:SYSTEM/fat16.c ****     
1494:SYSTEM/fat16.c ****             memcpy(&buffer[8], name_ext, name_ext_len);
1495:SYSTEM/fat16.c ****         }
1496:SYSTEM/fat16.c ****     
1497:SYSTEM/fat16.c ****         if(name_len <= 8)
1498:SYSTEM/fat16.c ****         {
1499:SYSTEM/fat16.c ****             memcpy(buffer, dir_entry->long_name, name_len);
1500:SYSTEM/fat16.c ****         }
1501:SYSTEM/fat16.c ****         else
1502:SYSTEM/fat16.c ****         {
1503:SYSTEM/fat16.c ****             memcpy(buffer, dir_entry->long_name, 8);
1504:SYSTEM/fat16.c ****     
1505:SYSTEM/fat16.c ****             /* Minimize 8.3 name clashes by appending
1506:SYSTEM/fat16.c ****                                              * the lower byte of the cluster number.
1507:SYSTEM/fat16.c ****                                              */
1508:SYSTEM/fat16.c ****             uint8_t num = dir_entry->cluster & 0xff;
1509:SYSTEM/fat16.c ****     
1510:SYSTEM/fat16.c ****             buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1511:SYSTEM/fat16.c ****             num &= 0x0f;
1512:SYSTEM/fat16.c ****             buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1513:SYSTEM/fat16.c ****         }
1514:SYSTEM/fat16.c ****     
1515:SYSTEM/fat16.c ****         /* fill directory entry buffer */
1516:SYSTEM/fat16.c ****         memset(&buffer[11], 0, sizeof(buffer) - 11);
1517:SYSTEM/fat16.c ****         buffer[0x0b] = dir_entry->attributes;
1518:SYSTEM/fat16.c **** 
1519:SYSTEM/fat16.c ****         //Not used in bootloader
1520:SYSTEM/fat16.c **** 		#ifdef MAIN_FIRMWARE
1521:SYSTEM/fat16.c **** 			//Added modified date/time 12-26-07
1522:SYSTEM/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1523:SYSTEM/fat16.c **** 			char * current_time;
1524:SYSTEM/fat16.c **** /*			current_time = GPS_get_time();
1525:SYSTEM/fat16.c **** 			char * current_date;
1526:SYSTEM/fat16.c **** 			current_date = GPS_get_date();
1527:SYSTEM/fat16.c **** 			
1528:SYSTEM/fat16.c **** 			uint16_t modified_time, modified_date;
1529:SYSTEM/fat16.c **** 			uint8_t c_hour, c_minute, c_second;
1530:SYSTEM/fat16.c **** 			uint8_t c_year, c_month, c_day;
1531:SYSTEM/fat16.c **** 			
1532:SYSTEM/fat16.c **** 			c_hour = (current_time[0] - '0') * 10;
1533:SYSTEM/fat16.c **** 			c_hour += (current_time[1] - '0');
1534:SYSTEM/fat16.c **** 			c_minute = (current_time[3] - '0') * 10;
1535:SYSTEM/fat16.c **** 			c_minute += (current_time[4] - '0');
1536:SYSTEM/fat16.c **** 			c_second = (current_time[6] - '0') * 10;
1537:SYSTEM/fat16.c **** 			c_second += (current_time[7] - '0');
1538:SYSTEM/fat16.c **** 			
1539:SYSTEM/fat16.c **** 			c_day = (current_date[0] - '0') * 10;
1540:SYSTEM/fat16.c **** 			c_day += (current_date[1] - '0');
1541:SYSTEM/fat16.c **** 			c_month = (current_date[3] - '0') * 10;
1542:SYSTEM/fat16.c **** 			c_month += (current_date[4] - '0');
1543:SYSTEM/fat16.c **** 			c_year = (current_date[6] - '0') * 10;
1544:SYSTEM/fat16.c **** 			c_year += (current_date[7] - '0');
1545:SYSTEM/fat16.c **** 			
1546:SYSTEM/fat16.c **** 			//Correct for 1980 = 0, 2000 = 20, year code
1547:SYSTEM/fat16.c **** 			c_year += 20;
1548:SYSTEM/fat16.c **** 			
1549:SYSTEM/fat16.c **** 			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
1550:SYSTEM/fat16.c **** 			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);
1551:SYSTEM/fat16.c **** 
1552:SYSTEM/fat16.c **** 			//Do a little error correction
1553:SYSTEM/fat16.c **** 			if (c_year < 26) //26 = 2006
1554:SYSTEM/fat16.c **** 			{
1555:SYSTEM/fat16.c **** 				modified_time = 0;
1556:SYSTEM/fat16.c **** 				modified_date = 0;
1557:SYSTEM/fat16.c **** 			}
1558:SYSTEM/fat16.c **** 
1559:SYSTEM/fat16.c **** 			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
1560:SYSTEM/fat16.c **** 			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
1561:SYSTEM/fat16.c **** 			//rprintf("mod_time=%x\n", modified_time);
1562:SYSTEM/fat16.c **** 			//rprintf("mod_date=%x\n", modified_date);
1563:SYSTEM/fat16.c **** 			
1564:SYSTEM/fat16.c **** 			buffer[0x16] = (modified_time >> 0) & 0xFF;
1565:SYSTEM/fat16.c **** 			buffer[0x17] = (modified_time >> 8) & 0xFF;
1566:SYSTEM/fat16.c **** 			buffer[0x18] = (modified_date >> 0) & 0xFF;
1567:SYSTEM/fat16.c **** 			buffer[0x19] = (modified_date >> 8) & 0xFF;
1568:SYSTEM/fat16.c **** 			*/
1569:SYSTEM/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1570:SYSTEM/fat16.c **** 		#endif
1571:SYSTEM/fat16.c **** 
1572:SYSTEM/fat16.c ****         buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
1573:SYSTEM/fat16.c ****         buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
1574:SYSTEM/fat16.c ****         buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
1575:SYSTEM/fat16.c ****         buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
1576:SYSTEM/fat16.c ****         buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
1577:SYSTEM/fat16.c ****         buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
1578:SYSTEM/fat16.c ****     
1579:SYSTEM/fat16.c ****         /* write to disk */
1580:SYSTEM/fat16.c ****         if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1581:SYSTEM/fat16.c ****             return 0;
1582:SYSTEM/fat16.c ****     
1583:SYSTEM/fat16.c ****         /* calculate checksum of 8.3 name */
1584:SYSTEM/fat16.c ****         uint8_t checksum = buffer[0];
1585:SYSTEM/fat16.c ****         uint8_t i;
1586:SYSTEM/fat16.c ****         for(i = 1; i < 11; ++i)
1587:SYSTEM/fat16.c ****             checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
1588:SYSTEM/fat16.c ****     
1589:SYSTEM/fat16.c ****         /* write lfn entries */
1590:SYSTEM/fat16.c ****         uint8_t lfn_entry;
1591:SYSTEM/fat16.c ****         for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1592:SYSTEM/fat16.c ****         {
1593:SYSTEM/fat16.c ****             memset(buffer, 0, sizeof(buffer));
1594:SYSTEM/fat16.c ****             memset(&buffer[0x01], 0xff, 10);
1595:SYSTEM/fat16.c ****             memset(&buffer[0x0e], 0xff, 12);
1596:SYSTEM/fat16.c ****             memset(&buffer[0x1c], 0xff, 4);
1597:SYSTEM/fat16.c ****     
1598:SYSTEM/fat16.c ****             buffer[0x00] = lfn_entry;
1599:SYSTEM/fat16.c ****             if(lfn_entry == lfn_entry_count)
1600:SYSTEM/fat16.c ****                 buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
1601:SYSTEM/fat16.c ****     
1602:SYSTEM/fat16.c ****             /* set file name */
1603:SYSTEM/fat16.c ****             const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
1604:SYSTEM/fat16.c ****             i = 1;
1605:SYSTEM/fat16.c ****             while(i < 0x1f)
1606:SYSTEM/fat16.c ****             {
1607:SYSTEM/fat16.c ****                 buffer[i++] = *long_name_curr;
1608:SYSTEM/fat16.c ****                 buffer[i++] = 0;
1609:SYSTEM/fat16.c ****     
1610:SYSTEM/fat16.c ****                 switch(i)
1611:SYSTEM/fat16.c ****                 {
1612:SYSTEM/fat16.c ****                     case 0x0b:
1613:SYSTEM/fat16.c ****                         i = 0x0e;
1614:SYSTEM/fat16.c ****                         break;
1615:SYSTEM/fat16.c ****                     case 0x1a:
1616:SYSTEM/fat16.c ****                         i = 0x1c;
1617:SYSTEM/fat16.c ****                         break;
1618:SYSTEM/fat16.c ****                 }
1619:SYSTEM/fat16.c ****     
1620:SYSTEM/fat16.c ****                 if(!*long_name_curr++)
1621:SYSTEM/fat16.c ****                     break;
1622:SYSTEM/fat16.c ****             }
1623:SYSTEM/fat16.c ****     
1624:SYSTEM/fat16.c ****             /* mark as lfn entry */
1625:SYSTEM/fat16.c ****             buffer[0x0b] = 0x0f;
1626:SYSTEM/fat16.c ****     
1627:SYSTEM/fat16.c ****             /* set checksum */
1628:SYSTEM/fat16.c ****             buffer[0x0d] = checksum;
1629:SYSTEM/fat16.c ****     
1630:SYSTEM/fat16.c ****             /* write entry */
1631:SYSTEM/fat16.c ****             device_write(offset, buffer, sizeof(buffer));
1632:SYSTEM/fat16.c ****     
1633:SYSTEM/fat16.c ****             offset += sizeof(buffer);
1634:SYSTEM/fat16.c ****         }
1635:SYSTEM/fat16.c ****     
1636:SYSTEM/fat16.c ****         return 1;
1637:SYSTEM/fat16.c ****     
1638:SYSTEM/fat16.c ****     #else
1639:SYSTEM/fat16.c ****         return 0;
1640:SYSTEM/fat16.c ****     #endif
1641:SYSTEM/fat16.c **** }
1642:SYSTEM/fat16.c **** 
1643:SYSTEM/fat16.c **** /**
1644:SYSTEM/fat16.c ****  * \ingroup fat16_file
1645:SYSTEM/fat16.c ****  * Creates a file.
1646:SYSTEM/fat16.c ****  *
1647:SYSTEM/fat16.c ****  * Creates a file and obtains the directory entry of the
1648:SYSTEM/fat16.c ****  * new file. If the file to create already exists, the
1649:SYSTEM/fat16.c ****  * directory entry of the existing file will be returned
1650:SYSTEM/fat16.c ****  * within the dir_entry parameter.
1651:SYSTEM/fat16.c ****  *
1652:SYSTEM/fat16.c ****  * \note The file name is not checked for invalid characters.
1653:SYSTEM/fat16.c ****  *
1654:SYSTEM/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1655:SYSTEM/fat16.c ****  * simple. The first eight characters are used for the filename.
1656:SYSTEM/fat16.c ****  * The extension, if any, is made up of the first three characters
1657:SYSTEM/fat16.c ****  * following the last dot within the long filename. If the
1658:SYSTEM/fat16.c ****  * filename (without the extension) is longer than eight characters,
1659:SYSTEM/fat16.c ****  * the lower byte of the cluster number replaces the last two
1660:SYSTEM/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1661:SYSTEM/fat16.c ****  * responsibility to avoid name clashes.
1662:SYSTEM/fat16.c ****  *
1663:SYSTEM/fat16.c ****  * \param[in] parent The handle of the directory in which to create the file.
1664:SYSTEM/fat16.c ****  * \param[in] file The name of the file to create.
1665:SYSTEM/fat16.c ****  * \param[out] dir_entry The directory entry to fill for the new file.
1666:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1667:SYSTEM/fat16.c ****  * \see fat16_delete_file
1668:SYSTEM/fat16.c ****  */
1669:SYSTEM/fat16.c **** uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry
1670:SYSTEM/fat16.c **** {
1671:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
1672:SYSTEM/fat16.c ****         if(!parent || !file || !file[0])
1673:SYSTEM/fat16.c ****             return 0;
1674:SYSTEM/fat16.c ****     
1675:SYSTEM/fat16.c ****         /* check if the file already exists */
1676:SYSTEM/fat16.c ****         while(1)
1677:SYSTEM/fat16.c ****         {
1678:SYSTEM/fat16.c ****             if(!fat16_read_dir(parent, dir_entry))
1679:SYSTEM/fat16.c ****                 break;
1680:SYSTEM/fat16.c ****     
1681:SYSTEM/fat16.c ****             if(strcmp(file, dir_entry->long_name) == 0)
1682:SYSTEM/fat16.c ****             {
1683:SYSTEM/fat16.c ****                 fat16_reset_dir(parent);
1684:SYSTEM/fat16.c ****                 return 1;
1685:SYSTEM/fat16.c ****             }
1686:SYSTEM/fat16.c ****         }
1687:SYSTEM/fat16.c ****     
1688:SYSTEM/fat16.c ****         memset(dir_entry, 0, sizeof(*dir_entry));
1689:SYSTEM/fat16.c ****         strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
1690:SYSTEM/fat16.c ****     
1691:SYSTEM/fat16.c ****         /* search for a place where to write the directory entry to disk */
1692:SYSTEM/fat16.c ****         uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
1693:SYSTEM/fat16.c ****         uint8_t free_dir_entries_found = 0;
1694:SYSTEM/fat16.c ****         struct fat16_fs_struct* fs = parent->fs;
1695:SYSTEM/fat16.c ****         uint16_t cluster_num = parent->dir_entry.cluster;
1696:SYSTEM/fat16.c ****         uint32_t dir_entry_offset = 0;
1697:SYSTEM/fat16.c ****         uint32_t offset = 0;
1698:SYSTEM/fat16.c ****         uint32_t offset_to = 0;
1699:SYSTEM/fat16.c ****     
1700:SYSTEM/fat16.c ****         if(cluster_num == 0)
1701:SYSTEM/fat16.c ****         {
1702:SYSTEM/fat16.c ****             /* we read/write from the root directory entry */
1703:SYSTEM/fat16.c ****             offset = fs->header.root_dir_offset;
1704:SYSTEM/fat16.c ****             offset_to = fs->header.cluster_zero_offset;
1705:SYSTEM/fat16.c ****             dir_entry_offset = offset;
1706:SYSTEM/fat16.c ****         }
1707:SYSTEM/fat16.c ****     
1708:SYSTEM/fat16.c ****         while(1)
1709:SYSTEM/fat16.c ****         {
1710:SYSTEM/fat16.c ****             if(offset == offset_to)
1711:SYSTEM/fat16.c ****             {
1712:SYSTEM/fat16.c ****                 if(cluster_num == 0)
1713:SYSTEM/fat16.c **** 				/* We iterated through the whole root directory entry
1714:SYSTEM/fat16.c ****                 * and could not find enough space for the directory entry.
1715:SYSTEM/fat16.c ****                 */
1716:SYSTEM/fat16.c ****                 return 0;
1717:SYSTEM/fat16.c ****     
1718:SYSTEM/fat16.c ****                 if(offset)
1719:SYSTEM/fat16.c ****                 {
1720:SYSTEM/fat16.c ****                     /* We reached a cluster boundary and have to
1721:SYSTEM/fat16.c ****                     * switch to the next cluster.
1722:SYSTEM/fat16.c ****                     */
1723:SYSTEM/fat16.c ****     
1724:SYSTEM/fat16.c ****                     uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
1725:SYSTEM/fat16.c ****                     if(!cluster_next)
1726:SYSTEM/fat16.c ****                     {
1727:SYSTEM/fat16.c ****                         cluster_next = fat16_append_clusters(fs, cluster_num, 1);
1728:SYSTEM/fat16.c ****                         if(!cluster_next)
1729:SYSTEM/fat16.c ****                             return 0;
1730:SYSTEM/fat16.c ****     
1731:SYSTEM/fat16.c ****                         /* we appended a new cluster and know it is free */
1732:SYSTEM/fat16.c ****                         dir_entry_offset = fs->header.cluster_zero_offset +
1733:SYSTEM/fat16.c ****                         (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
1734:SYSTEM/fat16.c ****     
1735:SYSTEM/fat16.c ****                         /* TODO: This cluster has to be zeroed in an efficient way, or at least
1736:SYSTEM/fat16.c ****                         *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
1737:SYSTEM/fat16.c ****                         */
1738:SYSTEM/fat16.c ****                         break;
1739:SYSTEM/fat16.c ****                     }
1740:SYSTEM/fat16.c ****                     cluster_num = cluster_next;
1741:SYSTEM/fat16.c ****                 }
1742:SYSTEM/fat16.c ****     
1743:SYSTEM/fat16.c ****                 offset = fs->header.cluster_zero_offset +
1744:SYSTEM/fat16.c ****                 (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
1745:SYSTEM/fat16.c ****                 offset_to = offset + fs->header.cluster_size;
1746:SYSTEM/fat16.c ****                 dir_entry_offset = offset;
1747:SYSTEM/fat16.c ****                 free_dir_entries_found = 0;
1748:SYSTEM/fat16.c ****             }
1749:SYSTEM/fat16.c ****     
1750:SYSTEM/fat16.c ****             /* read next lfn or 8.3 entry */
1751:SYSTEM/fat16.c ****             uint8_t first_char;
1752:SYSTEM/fat16.c ****             if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1753:SYSTEM/fat16.c ****                 return 0;
1754:SYSTEM/fat16.c ****     
1755:SYSTEM/fat16.c ****             /* check if we found a free directory entry */
1756:SYSTEM/fat16.c ****             if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
1757:SYSTEM/fat16.c ****             {
1758:SYSTEM/fat16.c ****                 /* check if we have the needed number of available entries */
1759:SYSTEM/fat16.c ****                 ++free_dir_entries_found;
1760:SYSTEM/fat16.c ****                 if(free_dir_entries_found >= free_dir_entries_needed)
1761:SYSTEM/fat16.c ****                     break;
1762:SYSTEM/fat16.c ****     
1763:SYSTEM/fat16.c ****                 offset += 32;
1764:SYSTEM/fat16.c ****             }
1765:SYSTEM/fat16.c ****             else
1766:SYSTEM/fat16.c ****             {
1767:SYSTEM/fat16.c ****                 offset += 32;
1768:SYSTEM/fat16.c ****                 dir_entry_offset = offset;
1769:SYSTEM/fat16.c ****                 free_dir_entries_found = 0;
1770:SYSTEM/fat16.c ****             }
1771:SYSTEM/fat16.c ****         }
1772:SYSTEM/fat16.c **** 
1773:SYSTEM/fat16.c ****         /* write directory entry to disk */
1774:SYSTEM/fat16.c ****         dir_entry->entry_offset = dir_entry_offset;
1775:SYSTEM/fat16.c ****         if(!fat16_write_dir_entry(fs, dir_entry))
1776:SYSTEM/fat16.c ****             return 0;
1777:SYSTEM/fat16.c ****     
1778:SYSTEM/fat16.c ****         return 1;
1779:SYSTEM/fat16.c ****     
1780:SYSTEM/fat16.c ****     #else
1781:SYSTEM/fat16.c ****         return 0;
1782:SYSTEM/fat16.c ****     #endif
1783:SYSTEM/fat16.c **** }
1784:SYSTEM/fat16.c **** 
1785:SYSTEM/fat16.c **** /**
1786:SYSTEM/fat16.c ****  * \ingroup fat16_file
1787:SYSTEM/fat16.c ****  * Deletes a file or directory.
1788:SYSTEM/fat16.c ****  *
1789:SYSTEM/fat16.c ****  * It is not checked if the file to delete is a directory.
1790:SYSTEM/fat16.c ****  * If a directory is deleted without first deleting its
1791:SYSTEM/fat16.c ****  * subdirectories and files, disk space occupied by these
1792:SYSTEM/fat16.c ****  * files will get wasted as there is no chance to release
1793:SYSTEM/fat16.c ****  * it and mark it as free.
1794:SYSTEM/fat16.c ****  *
1795:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1796:SYSTEM/fat16.c ****  * \param[in] dir_entry The directory entry of the file to delete.
1797:SYSTEM/fat16.c ****  * \returns 0 on failure, 1 on success.
1798:SYSTEM/fat16.c ****  * \see fat16_create_file
1799:SYSTEM/fat16.c ****  */
1800:SYSTEM/fat16.c **** uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
1801:SYSTEM/fat16.c **** {
 898              		.loc 1 1801 0
 899              		@ Function supports interworking.
 900              		@ args = 0, pretend = 0, frame = 16
 901              		@ frame_needed = 0, uses_anonymous_args = 0
 902              	.LVL104:
1802:SYSTEM/fat16.c ****     #if FAT16_WRITE_SUPPORT
1803:SYSTEM/fat16.c ****         if(!fs || !dir_entry)
 903              		.loc 1 1803 0
 904 0698 000050E3 		cmp	r0, #0
 905 069c 00005113 		cmpne	r1, #0
 906              		.loc 1 1801 0
 907 06a0 FF412DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 908              	.LCFI6:
 909              	.LVL105:
 910              		.loc 1 1803 0
 911 06a4 0160A0E1 		mov	r6, r1
 912              	.LVL106:
 913 06a8 0050A0E1 		mov	r5, r0
 914              	.LVL107:
 915 06ac 1F00000A 		beq	.L84
 916              	.LVL108:
1804:SYSTEM/fat16.c ****             return 0;
1805:SYSTEM/fat16.c ****     
1806:SYSTEM/fat16.c ****         /* get offset of the file's directory entry */
1807:SYSTEM/fat16.c ****         uint32_t dir_entry_offset = dir_entry->entry_offset;
 917              		.loc 1 1807 0
 918 06b0 284091E5 		ldr	r4, [r1, #40]
 919              	.LVL109:
1808:SYSTEM/fat16.c ****         if(!dir_entry_offset)
 920              		.loc 1 1808 0
 921 06b4 000054E3 		cmp	r4, #0
 922 06b8 1C00000A 		beq	.L84
 923              	.LVL110:
1809:SYSTEM/fat16.c ****             return 0;
1810:SYSTEM/fat16.c ****     
1811:SYSTEM/fat16.c ****         uint8_t buffer[12];
1812:SYSTEM/fat16.c ****         while(1)
1813:SYSTEM/fat16.c ****         {
1814:SYSTEM/fat16.c ****             /* read directory entry */
1815:SYSTEM/fat16.c ****             if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
 924              		.loc 1 1815 0
 925 06bc 04708DE2 		add	r7, sp, #4
1816:SYSTEM/fat16.c ****                 return 0;
1817:SYSTEM/fat16.c ****     
1818:SYSTEM/fat16.c ****             /* mark the directory entry as deleted */
1819:SYSTEM/fat16.c ****             buffer[0] = FAT16_DIRENTRY_DELETED;
 926              		.loc 1 1819 0
 927 06c0 1A80E0E3 		mvn	r8, #26
 928              	.LVL111:
 929              	.L89:
 930              		.loc 1 1815 0
 931 06c4 0710A0E1 		mov	r1, r7
 932 06c8 0C20A0E3 		mov	r2, #12
 933 06cc 003095E5 		ldr	r3, [r5, #0]
 934 06d0 0400A0E1 		mov	r0, r4
 935 06d4 00C093E5 		ldr	ip, [r3, #0]
 936 06d8 0FE0A0E1 		mov	lr, pc
 937 06dc 1CFF2FE1 		bx	ip
 938 06e0 000050E3 		cmp	r0, #0
1820:SYSTEM/fat16.c ****     
1821:SYSTEM/fat16.c ****             /* write back entry */
1822:SYSTEM/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
 939              		.loc 1 1822 0
 940 06e4 0710A0E1 		mov	r1, r7
 941 06e8 0C20A0E3 		mov	r2, #12
 942 06ec 0400A0E1 		mov	r0, r4
 943              		.loc 1 1815 0
 944 06f0 0E00000A 		beq	.L84
 945              		.loc 1 1819 0
 946 06f4 0480CDE5 		strb	r8, [sp, #4]
 947              		.loc 1 1822 0
 948 06f8 003095E5 		ldr	r3, [r5, #0]
 949 06fc 08C093E5 		ldr	ip, [r3, #8]
 950 0700 0FE0A0E1 		mov	lr, pc
 951 0704 1CFF2FE1 		bx	ip
 952 0708 000050E3 		cmp	r0, #0
 953 070c 0700000A 		beq	.L84
1823:SYSTEM/fat16.c ****                 return 0;
1824:SYSTEM/fat16.c ****     
1825:SYSTEM/fat16.c ****             /* check if we deleted the whole entry */
1826:SYSTEM/fat16.c ****             if(buffer[11] != 0x0f)
 954              		.loc 1 1826 0
 955 0710 0F30DDE5 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 956 0714 0F0053E3 		cmp	r3, #15
1827:SYSTEM/fat16.c ****                 break;
1828:SYSTEM/fat16.c ****     
1829:SYSTEM/fat16.c ****             dir_entry_offset += 32;
 957              		.loc 1 1829 0
 958 0718 20408402 		addeq	r4, r4, #32
1830:SYSTEM/fat16.c ****         }
 959              		.loc 1 1830 0
 960 071c E8FFFF0A 		beq	.L89
 961              	.L85:
1831:SYSTEM/fat16.c ****     
1832:SYSTEM/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1833:SYSTEM/fat16.c ****                              * marking all occupied clusters as free.
1834:SYSTEM/fat16.c ****                              */
1835:SYSTEM/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 962              		.loc 1 1835 0
 963 0720 0500A0E1 		mov	r0, r5
 964 0724 B212D6E1 		ldrh	r1, [r6, #34]
 965 0728 DFFEFFEB 		bl	fat16_free_clusters
 966 072c 000000EA 		b	.L87
 967              	.LVL112:
 968              	.L84:
 969 0730 0000A0E3 		mov	r0, #0
 970              	.L87:
1836:SYSTEM/fat16.c ****     #else
1837:SYSTEM/fat16.c ****         return 0;
1838:SYSTEM/fat16.c ****     #endif
1839:SYSTEM/fat16.c **** }
 971              		.loc 1 1839 0
 972 0734 10D08DE2 		add	sp, sp, #16
 973 0738 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 974 073c 1EFF2FE1 		bx	lr
 975              	.LFE26:
 977              		.align	2
 978              		.global	fat16_get_fs_size
 980              	fat16_get_fs_size:
 981              	.LFB27:
1840:SYSTEM/fat16.c **** 
1841:SYSTEM/fat16.c **** /**
1842:SYSTEM/fat16.c ****  * \ingroup fat16_fs
1843:SYSTEM/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1844:SYSTEM/fat16.c ****  *
1845:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1846:SYSTEM/fat16.c ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
1847:SYSTEM/fat16.c ****  */
1848:SYSTEM/fat16.c **** uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
1849:SYSTEM/fat16.c **** {
 982              		.loc 1 1849 0
 983              		@ Function supports interworking.
 984              		@ args = 0, pretend = 0, frame = 0
 985              		@ frame_needed = 0, uses_anonymous_args = 0
 986              		@ link register save eliminated.
 987              	.LVL113:
1850:SYSTEM/fat16.c ****     if(!fs)
 988              		.loc 1 1850 0
 989 0740 000050E3 		cmp	r0, #0
 990 0744 1EFF2F01 		bxeq	lr
1851:SYSTEM/fat16.c ****         return 0;
1852:SYSTEM/fat16.c **** 
1853:SYSTEM/fat16.c ****     return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
 991              		.loc 1 1853 0
 992 0748 0C2090E5 		ldr	r2, [r0, #12]
 993 074c B231D0E1 		ldrh	r3, [r0, #18]
 994 0750 A200A0E1 		mov	r0, r2, lsr #1
 995              	.LVL114:
 996 0754 020040E2 		sub	r0, r0, #2
 997 0758 930000E0 		mul	r0, r3, r0
1854:SYSTEM/fat16.c **** }
 998              		.loc 1 1854 0
 999 075c 1EFF2FE1 		bx	lr
 1000              	.LFE27:
 1002              		.align	2
 1003              		.global	fat16_get_fs_free
 1005              	fat16_get_fs_free:
 1006              	.LFB28:
1855:SYSTEM/fat16.c **** 
1856:SYSTEM/fat16.c **** /**
1857:SYSTEM/fat16.c ****  * \ingroup fat16_fs
1858:SYSTEM/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
1859:SYSTEM/fat16.c ****  *
1860:SYSTEM/fat16.c ****  * \note As the FAT16 filesystem is cluster based, this function does not
1861:SYSTEM/fat16.c ****  *       return continuous values but multiples of the cluster size.
1862:SYSTEM/fat16.c ****  *
1863:SYSTEM/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1864:SYSTEM/fat16.c ****  * \returns 0 on failure, the free filesystem space in bytes otherwise.
1865:SYSTEM/fat16.c ****  */
1866:SYSTEM/fat16.c **** uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
1867:SYSTEM/fat16.c **** {
 1007              		.loc 1 1867 0
 1008              		@ Function supports interworking.
 1009              		@ args = 0, pretend = 0, frame = 40
 1010              		@ frame_needed = 0, uses_anonymous_args = 0
 1011              	.LVL115:
 1012 0760 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1013              	.LCFI7:
1868:SYSTEM/fat16.c ****     if(!fs)
 1014              		.loc 1 1868 0
 1015 0764 005050E2 		subs	r5, r0, #0
 1016              		.loc 1 1867 0
 1017 0768 34D04DE2 		sub	sp, sp, #52
 1018              	.LCFI8:
 1019              		.loc 1 1868 0
 1020 076c 2100000A 		beq	.L95
 1021              	.LVL116:
1869:SYSTEM/fat16.c ****         return 0;
1870:SYSTEM/fat16.c **** 
1871:SYSTEM/fat16.c ****     uint8_t fat[32];
1872:SYSTEM/fat16.c ****     struct fat16_usage_count_callback_arg count_arg;
1873:SYSTEM/fat16.c ****     count_arg.cluster_count = 0;
1874:SYSTEM/fat16.c ****     count_arg.buffer_size = sizeof(fat);
 1022              		.loc 1 1874 0
 1023 0770 2030A0E3 		mov	r3, #32
 1024 0774 2E30CDE5 		strb	r3, [sp, #46]
 1025              		.loc 1 1873 0
 1026 0778 0030A0E3 		mov	r3, #0	@ movhi
 1027 077c BC32CDE1 		strh	r3, [sp, #44]	@ movhi
1875:SYSTEM/fat16.c **** 
1876:SYSTEM/fat16.c ****     uint32_t fat_offset = fs->header.fat_offset;
 1028              		.loc 1 1876 0
 1029 0780 087095E5 		ldr	r7, [r5, #8]
 1030              	.LVL117:
1877:SYSTEM/fat16.c ****     uint32_t fat_size = fs->header.fat_size;
 1031              		.loc 1 1877 0
 1032 0784 0C4095E5 		ldr	r4, [r5, #12]
 1033              	.LVL118:
 1034              	.LBB28:
1878:SYSTEM/fat16.c ****     while(fat_size > 0)
1879:SYSTEM/fat16.c ****     {
1880:SYSTEM/fat16.c ****         uint16_t length = UINT16_MAX - 1;
1881:SYSTEM/fat16.c ****         if(fat_size < length)
 1035              		.loc 1 1881 0
 1036 0788 78809FE5 		ldr	r8, .L102
1882:SYSTEM/fat16.c ****             length = fat_size;
1883:SYSTEM/fat16.c **** 
1884:SYSTEM/fat16.c ****         if(!fs->partition->device_read_interval(fat_offset,
 1037              		.loc 1 1884 0
 1038 078c 0CA08DE2 		add	sl, sp, #12
 1039 0790 74909FE5 		ldr	r9, .L102+4
 1040 0794 2CB08DE2 		add	fp, sp, #44
 1041              	.LBE28:
 1042              		.loc 1 1878 0
 1043 0798 100000EA 		b	.L96
 1044              	.LVL119:
 1045              	.L99:
 1046              	.LBB29:
 1047              		.loc 1 1881 0
 1048 079c 080054E1 		cmp	r4, r8
 1049              		.loc 1 1882 0
 1050 07a0 0468A091 		movls	r6, r4, asl #16
 1051              	.LVL120:
 1052              		.loc 1 1881 0
 1053 07a4 64609F85 		ldrhi	r6, .L102+8
 1054              	.LVL121:
 1055              		.loc 1 1882 0
 1056 07a8 2668A091 		movls	r6, r6, lsr #16
 1057              	.LVL122:
 1058              		.loc 1 1884 0
 1059 07ac 00C095E5 		ldr	ip, [r5, #0]
 1060 07b0 0700A0E1 		mov	r0, r7
 1061 07b4 000A8DE8 		stmia	sp, {r9, fp}	@ phole stm
 1062 07b8 0A10A0E1 		mov	r1, sl
 1063 07bc 2020A0E3 		mov	r2, #32
 1064 07c0 0630A0E1 		mov	r3, r6
 1065 07c4 04C09CE5 		ldr	ip, [ip, #4]
 1066 07c8 0FE0A0E1 		mov	lr, pc
 1067 07cc 1CFF2FE1 		bx	ip
 1068 07d0 000050E3 		cmp	r0, #0
 1069 07d4 0700000A 		beq	.L95
1885:SYSTEM/fat16.c ****             fat,
1886:SYSTEM/fat16.c ****            sizeof(fat),
1887:SYSTEM/fat16.c ****            length,
1888:SYSTEM/fat16.c ****            fat16_get_fs_free_callback,
1889:SYSTEM/fat16.c ****            &count_arg
1890:SYSTEM/fat16.c ****            )
1891:SYSTEM/fat16.c ****            )
1892:SYSTEM/fat16.c ****         return 0;
1893:SYSTEM/fat16.c **** 
1894:SYSTEM/fat16.c ****         fat_offset += length;
1895:SYSTEM/fat16.c ****         fat_size -= length;
 1070              		.loc 1 1895 0
 1071 07d8 044066E0 		rsb	r4, r6, r4
 1072              		.loc 1 1894 0
 1073 07dc 067087E0 		add	r7, r7, r6
 1074              	.LVL123:
 1075              	.L96:
 1076              	.LBE29:
 1077              		.loc 1 1878 0
 1078 07e0 000054E3 		cmp	r4, #0
 1079 07e4 ECFFFF1A 		bne	.L99
1896:SYSTEM/fat16.c ****     }
1897:SYSTEM/fat16.c **** 
1898:SYSTEM/fat16.c ****     return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
 1080              		.loc 1 1898 0
 1081 07e8 B231D5E1 		ldrh	r3, [r5, #18]
 1082 07ec BC02DDE1 		ldrh	r0, [sp, #44]
 1083 07f0 930000E0 		mul	r0, r3, r0
 1084 07f4 000000EA 		b	.L100
 1085              	.LVL124:
 1086              	.L95:
 1087 07f8 0000A0E3 		mov	r0, #0
 1088              	.L100:
1899:SYSTEM/fat16.c **** }
 1089              		.loc 1 1899 0
 1090 07fc 34D08DE2 		add	sp, sp, #52
 1091 0800 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1092 0804 1EFF2FE1 		bx	lr
 1093              	.L103:
 1094              		.align	2
 1095              	.L102:
 1096 0808 FDFF0000 		.word	65533
 1097 080c 00000000 		.word	fat16_get_fs_free_callback
 1098 0810 FEFF0000 		.word	65534
 1099              	.LFE28:
 1101              		.align	2
 1103              	fat16_get_fs_free_callback:
 1104              	.LFB29:
1900:SYSTEM/fat16.c **** 
1901:SYSTEM/fat16.c **** /**
1902:SYSTEM/fat16.c ****  * \ingroup fat16_fs
1903:SYSTEM/fat16.c ****  * Callback function used for counting free clusters.
1904:SYSTEM/fat16.c ****  */
1905:SYSTEM/fat16.c **** uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
1906:SYSTEM/fat16.c **** {
 1105              		.loc 1 1906 0
 1106              		@ Function supports interworking.
 1107              		@ args = 0, pretend = 0, frame = 0
 1108              		@ frame_needed = 0, uses_anonymous_args = 0
 1109              		@ link register save eliminated.
 1110              	.LVL125:
 1111 0814 04402DE5 		str	r4, [sp, #-4]!
 1112              	.LCFI9:
1907:SYSTEM/fat16.c ****     struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
1908:SYSTEM/fat16.c ****     uint8_t buffer_size = count_arg->buffer_size;
 1113              		.loc 1 1908 0
 1114 0818 0210D2E5 		ldrb	r1, [r2, #2]	@ zero_extendqisi2
 1115              	.LVL126:
 1116 081c 0030A0E3 		mov	r3, #0
 1117              	.LVL127:
1909:SYSTEM/fat16.c ****     uint8_t i;
1910:SYSTEM/fat16.c ****     for(i = 0; i < buffer_size; i += 2)
 1118              		.loc 1 1910 0
 1119 0820 080000EA 		b	.L105
 1120              	.L107:
1911:SYSTEM/fat16.c ****     {
1912:SYSTEM/fat16.c ****         if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
 1121              		.loc 1 1912 0
 1122 0824 00C0D0E5 		ldrb	ip, [r0, #0]	@ zero_extendqisi2
 1123 0828 0140D0E5 		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 1124 082c 04C49CE1 		orrs	ip, ip, r4, asl #8
1913:SYSTEM/fat16.c ****             ++(count_arg->cluster_count);
 1125              		.loc 1 1913 0
 1126 0830 B0C0D201 		ldreqh	ip, [r2, #0]
 1127 0834 01C08C02 		addeq	ip, ip, #1
 1128              		.loc 1 1910 0
 1129 0838 023083E2 		add	r3, r3, #2
 1130              	.LVL128:
 1131              		.loc 1 1913 0
 1132 083c B0C0C201 		streqh	ip, [r2, #0]	@ movhi
1914:SYSTEM/fat16.c **** 
1915:SYSTEM/fat16.c ****         buffer += 2;
 1133              		.loc 1 1915 0
 1134 0840 020080E2 		add	r0, r0, #2
 1135              	.LVL129:
 1136              		.loc 1 1910 0
 1137 0844 FF3003E2 		and	r3, r3, #255
 1138              	.LVL130:
 1139              	.L105:
 1140 0848 010053E1 		cmp	r3, r1
 1141 084c F4FFFF3A 		bcc	.L107
1916:SYSTEM/fat16.c ****     }
1917:SYSTEM/fat16.c **** 
1918:SYSTEM/fat16.c ****     return 1;
1919:SYSTEM/fat16.c **** }
 1142              		.loc 1 1919 0
 1143 0850 0100A0E3 		mov	r0, #1
 1144              	.LVL131:
 1145 0854 1000BDE8 		ldmfd	sp!, {r4}
 1146 0858 1EFF2FE1 		bx	lr
 1147              	.LFE29:
 1149              		.align	2
 1150              		.global	fat16_file_size
 1152              	fat16_file_size:
 1153              	.LFB32:
1920:SYSTEM/fat16.c **** 
1921:SYSTEM/fat16.c **** uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name,
1922:SYSTEM/fat16.c **** {
1923:SYSTEM/fat16.c ****     while(fat16_read_dir(dd, dir_entry))
1924:SYSTEM/fat16.c ****     {
1925:SYSTEM/fat16.c ****         if(strcmp(dir_entry->long_name, name) == 0)
1926:SYSTEM/fat16.c ****         {
1927:SYSTEM/fat16.c ****             fat16_reset_dir(dd);
1928:SYSTEM/fat16.c ****             return 1;
1929:SYSTEM/fat16.c ****         }
1930:SYSTEM/fat16.c ****     }
1931:SYSTEM/fat16.c **** 
1932:SYSTEM/fat16.c ****     return 0;
1933:SYSTEM/fat16.c **** }
1934:SYSTEM/fat16.c **** 
1935:SYSTEM/fat16.c **** struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd,
1936:SYSTEM/fat16.c **** {
1937:SYSTEM/fat16.c ****     struct fat16_dir_entry_struct file_entry;
1938:SYSTEM/fat16.c ****     if(!find_file_in_dir(fs, dd, name, &file_entry))
1939:SYSTEM/fat16.c ****         return 0;
1940:SYSTEM/fat16.c **** 
1941:SYSTEM/fat16.c ****     return fat16_open_file(fs, &file_entry);
1942:SYSTEM/fat16.c **** }
1943:SYSTEM/fat16.c **** 
1944:SYSTEM/fat16.c **** int fat16_file_size(struct fat16_file_struct * file)
1945:SYSTEM/fat16.c **** {
 1154              		.loc 1 1945 0
 1155              		@ Function supports interworking.
 1156              		@ args = 0, pretend = 0, frame = 0
 1157              		@ frame_needed = 0, uses_anonymous_args = 0
 1158              		@ link register save eliminated.
 1159              	.LVL132:
1946:SYSTEM/fat16.c ****     return(file->dir_entry.file_size);
1947:SYSTEM/fat16.c **** }
 1160              		.loc 1 1947 0
 1161 085c 280090E5 		ldr	r0, [r0, #40]
 1162              	.LVL133:
 1163 0860 1EFF2FE1 		bx	lr
 1164              	.LFE32:
 1166              		.align	2
 1167              		.global	fat16_read_dir
 1169              	fat16_read_dir:
 1170              	.LFB21:
 1171              		.loc 1 1390 0
 1172              		@ Function supports interworking.
 1173              		@ args = 0, pretend = 0, frame = 56
 1174              		@ frame_needed = 0, uses_anonymous_args = 0
 1175              	.LVL134:
 1176 0864 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1177              	.LCFI10:
 1178              		.loc 1 1391 0
 1179 0868 000050E3 		cmp	r0, #0
 1180 086c 00005113 		cmpne	r1, #0
 1181              		.loc 1 1390 0
 1182 0870 44D04DE2 		sub	sp, sp, #68
 1183              	.LCFI11:
 1184              		.loc 1 1391 0
 1185 0874 0160A0E1 		mov	r6, r1
 1186 0878 0040A0E1 		mov	r4, r0
 1187 087c 7200000A 		beq	.L120
 1188              	.LVL135:
 1189              		.loc 1 1394 0
 1190 0880 B672D0E1 		ldrh	r7, [r0, #38]
 1191              	.LVL136:
 1192 0884 B023D0E1 		ldrh	r2, [r0, #48]
 1193 0888 000057E3 		cmp	r7, #0
 1194 088c 005090E5 		ldr	r5, [r0, #0]
 1195 0890 0C208DE5 		str	r2, [sp, #12]
 1196 0894 2800001A 		bne	.L114
 1197              	.LVL137:
 1198              	.LBB34:
 1199              	.LBB35:
 1200              		.loc 1 358 0
 1201 0898 000055E3 		cmp	r5, #0
 1202 089c 6800000A 		beq	.L115
 1203              		.loc 1 363 0
 1204 08a0 003095E5 		ldr	r3, [r5, #0]
 1205              		.loc 1 368 0
 1206 08a4 34808DE2 		add	r8, sp, #52
 1207 08a8 0710A0E1 		mov	r1, r7
 1208 08ac 0C20A0E3 		mov	r2, #12
 1209 08b0 0800A0E1 		mov	r0, r8
 1210              	.LVL138:
 1211              		.loc 1 363 0
 1212 08b4 04A093E5 		ldr	sl, [r3, #4]
 1213              	.LVL139:
 1214              		.loc 1 368 0
 1215 08b8 FEFFFFEB 		bl	memset
 1216              		.loc 1 370 0
 1217 08bc 140085E2 		add	r0, r5, #20
 1218 08c0 090090E8 		ldmia	r0, {r0, r3}	@ phole ldm
 1219              		.loc 1 369 0
 1220 08c4 0C209DE5 		ldr	r2, [sp, #12]
 1221              		.loc 1 370 0
 1222 08c8 033060E0 		rsb	r3, r0, r3
 1223              		.loc 1 369 0
 1224 08cc B623CDE1 		strh	r2, [sp, #54]	@ movhi
 1225              		.loc 1 370 0
 1226 08d0 84219FE5 		ldr	r2, .L126
 1227 08d4 0338A0E1 		mov	r3, r3, asl #16
 1228 08d8 14508DE2 		add	r5, sp, #20
 1229 08dc 04018DE8 		stmia	sp, {r2, r8}	@ phole stm
 1230 08e0 2338A0E1 		mov	r3, r3, lsr #16
 1231 08e4 0510A0E1 		mov	r1, r5
 1232 08e8 2020A0E3 		mov	r2, #32
 1233 08ec 0FE0A0E1 		mov	lr, pc
 1234 08f0 1AFF2FE1 		bx	sl
 1235 08f4 000050E3 		cmp	r0, #0
 1236 08f8 5100000A 		beq	.L115
 1237 08fc 38309DE5 		ldr	r3, [sp, #56]
 1238 0900 000053E3 		cmp	r3, #0
 1239 0904 4E00000A 		beq	.L115
 1240              		.loc 1 381 0
 1241 0908 0710A0E1 		mov	r1, r7
 1242 090c 2C20A0E3 		mov	r2, #44
 1243 0910 0600A0E1 		mov	r0, r6
 1244 0914 FEFFFFEB 		bl	memset
 1245              		.loc 1 382 0
 1246 0918 40219FE5 		ldr	r2, .L126+4
 1247 091c 3C30DDE5 		ldrb	r3, [sp, #60]	@ zero_extendqisi2
 1248 0920 44008DE8 		stmia	sp, {r2, r6}	@ phole stm
 1249 0924 0510A0E1 		mov	r1, r5
 1250 0928 38009DE5 		ldr	r0, [sp, #56]
 1251 092c 2020A0E3 		mov	r2, #32
 1252 0930 0FE0A0E1 		mov	lr, pc
 1253 0934 1AFF2FE1 		bx	sl
 1254 0938 360000EA 		b	.L125
 1255              	.LVL140:
 1256              	.L114:
 1257              	.LBE35:
 1258              	.LBE34:
 1259              	.LBB36:
 1260              	.LBB37:
 1261              		.loc 1 406 0
 1262 093c 000055E3 		cmp	r5, #0
 1263 0940 3F00000A 		beq	.L115
 1264              		.loc 1 1406 0
 1265 0944 2430D0E5 		ldrb	r3, [r0, #36]	@ zero_extendqisi2
 1266 0948 100013E3 		tst	r3, #16
 1267 094c 3C00000A 		beq	.L115
 1268              		.loc 1 416 0
 1269 0950 B281D5E1 		ldrh	r8, [r5, #18]
 1270              	.LVL141:
 1271              		.loc 1 426 0
 1272 0954 34908DE2 		add	r9, sp, #52
 1273              		.loc 1 428 0
 1274 0958 14B08DE2 		add	fp, sp, #20
 1275 095c 00A0A0E1 		mov	sl, r0
 1276              	.LVL142:
 1277              	.L117:
 1278              		.loc 1 423 0
 1279 0960 183095E5 		ldr	r3, [r5, #24]
 1280 0964 024047E2 		sub	r4, r7, #2
 1281              	.LVL143:
 1282 0968 983424E0 		mla	r4, r8, r4, r3
 1283              	.LVL144:
 1284              		.loc 1 426 0
 1285 096c 0010A0E3 		mov	r1, #0
 1286 0970 0C20A0E3 		mov	r2, #12
 1287 0974 0900A0E1 		mov	r0, r9
 1288 0978 FEFFFFEB 		bl	memset
 1289              		.loc 1 427 0
 1290 097c 0C309DE5 		ldr	r3, [sp, #12]
 1291              		.loc 1 428 0
 1292 0980 D4209FE5 		ldr	r2, .L126
 1293 0984 00C095E5 		ldr	ip, [r5, #0]
 1294              		.loc 1 427 0
 1295 0988 B633CDE1 		strh	r3, [sp, #54]	@ movhi
 1296              		.loc 1 428 0
 1297 098c 00208DE5 		str	r2, [sp, #0]
 1298 0990 0B10A0E1 		mov	r1, fp
 1299 0994 0400A0E1 		mov	r0, r4
 1300 0998 04908DE5 		str	r9, [sp, #4]
 1301 099c 2020A0E3 		mov	r2, #32
 1302 09a0 0830A0E1 		mov	r3, r8
 1303 09a4 04C09CE5 		ldr	ip, [ip, #4]
 1304 09a8 0FE0A0E1 		mov	lr, pc
 1305 09ac 1CFF2FE1 		bx	ip
 1306 09b0 000050E3 		cmp	r0, #0
 1307              		.loc 1 442 0
 1308 09b4 0710A0E1 		mov	r1, r7
 1309 09b8 0500A0E1 		mov	r0, r5
 1310              		.loc 1 428 0
 1311 09bc 1F00000A 		beq	.L119
 1312              		.loc 1 438 0
 1313 09c0 38309DE5 		ldr	r3, [sp, #56]
 1314 09c4 000053E3 		cmp	r3, #0
 1315 09c8 0300001A 		bne	.L116
 1316              		.loc 1 442 0
 1317 09cc 13FEFFEB 		bl	fat16_get_next_cluster
 1318 09d0 007050E2 		subs	r7, r0, #0
 1319              	.LVL145:
 1320 09d4 E1FFFF1A 		bne	.L117
 1321 09d8 180000EA 		b	.L119
 1322              	.L116:
 1323              		.loc 1 446 0
 1324 09dc 0010A0E3 		mov	r1, #0
 1325 09e0 2C20A0E3 		mov	r2, #44
 1326 09e4 0600A0E1 		mov	r0, r6
 1327 09e8 FEFFFFEB 		bl	memset
 1328              		.loc 1 449 0
 1329 09ec 6C209FE5 		ldr	r2, .L126+4
 1330 09f0 00C095E5 		ldr	ip, [r5, #0]
 1331 09f4 3C30DDE5 		ldrb	r3, [sp, #60]	@ zero_extendqisi2
 1332 09f8 44008DE8 		stmia	sp, {r2, r6}	@ phole stm
 1333 09fc 0B10A0E1 		mov	r1, fp
 1334 0a00 38009DE5 		ldr	r0, [sp, #56]
 1335 0a04 2020A0E3 		mov	r2, #32
 1336 0a08 0A40A0E1 		mov	r4, sl
 1337              	.LVL146:
 1338 0a0c 04C09CE5 		ldr	ip, [ip, #4]
 1339 0a10 0FE0A0E1 		mov	lr, pc
 1340 0a14 1CFF2FE1 		bx	ip
 1341              	.LVL147:
 1342              	.L125:
 1343 0a18 000050E3 		cmp	r0, #0
 1344 0a1c 0800000A 		beq	.L115
 1345              	.LBE37:
 1346              	.LBE36:
 1347              		.loc 1 457 0
 1348 0a20 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 1349 0a24 000053E3 		cmp	r3, #0
 1350 0a28 0500000A 		beq	.L115
 1351              		.loc 1 1408 0
 1352 0a2c B033D4E1 		ldrh	r3, [r4, #48]
 1353 0a30 013083E2 		add	r3, r3, #1
 1354 0a34 B033C4E1 		strh	r3, [r4, #48]	@ movhi
 1355 0a38 0100A0E3 		mov	r0, #1
 1356              		.loc 1 1409 0
 1357 0a3c 030000EA 		b	.L113
 1358              	.LVL148:
 1359              	.L119:
 1360 0a40 0A40A0E1 		mov	r4, sl
 1361              	.LVL149:
 1362              	.L115:
 1363              		.loc 1 1414 0
 1364 0a44 0030A0E3 		mov	r3, #0	@ movhi
 1365 0a48 B033C4E1 		strh	r3, [r4, #48]	@ movhi
 1366              	.L120:
 1367 0a4c 0000A0E3 		mov	r0, #0
 1368              	.L113:
 1369              		.loc 1 1417 0
 1370 0a50 44D08DE2 		add	sp, sp, #68
 1371 0a54 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1372 0a58 1EFF2FE1 		bx	lr
 1373              	.L127:
 1374              		.align	2
 1375              	.L126:
 1376 0a5c 00000000 		.word	fat16_dir_entry_seek_callback
 1377 0a60 00000000 		.word	fat16_dir_entry_read_callback
 1378              	.LFE21:
 1380              		.align	2
 1381              		.global	find_file_in_dir
 1383              	find_file_in_dir:
 1384              	.LFB30:
 1385              		.loc 1 1922 0
 1386              		@ Function supports interworking.
 1387              		@ args = 0, pretend = 0, frame = 0
 1388              		@ frame_needed = 0, uses_anonymous_args = 0
 1389              	.LVL150:
 1390 0a64 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1391              	.LCFI12:
 1392              		.loc 1 1922 0
 1393 0a68 0140A0E1 		mov	r4, r1
 1394 0a6c 0250A0E1 		mov	r5, r2
 1395 0a70 0360A0E1 		mov	r6, r3
 1396              		.loc 1 1923 0
 1397 0a74 060000EA 		b	.L129
 1398              	.LVL151:
 1399              	.L132:
 1400              		.loc 1 1925 0
 1401 0a78 FEFFFFEB 		bl	strcmp
 1402 0a7c 000050E3 		cmp	r0, #0
 1403 0a80 0300001A 		bne	.L129
 1404              	.LBB38:
 1405              	.LBB39:
 1406              		.loc 1 1432 0
 1407 0a84 000054E3 		cmp	r4, #0
 1408              		.loc 1 1435 0
 1409 0a88 B003C411 		strneh	r0, [r4, #48]	@ movhi
 1410 0a8c 0100A0E3 		mov	r0, #1
 1411 0a90 070000EA 		b	.L131
 1412              	.LVL152:
 1413              	.L129:
 1414              	.LBE39:
 1415              	.LBE38:
 1416              		.loc 1 1923 0
 1417 0a94 0610A0E1 		mov	r1, r6
 1418 0a98 0400A0E1 		mov	r0, r4
 1419              	.LVL153:
 1420 0a9c FEFFFFEB 		bl	fat16_read_dir
 1421 0aa0 003050E2 		subs	r3, r0, #0
 1422              		.loc 1 1925 0
 1423 0aa4 0510A0E1 		mov	r1, r5
 1424 0aa8 0600A0E1 		mov	r0, r6
 1425              		.loc 1 1923 0
 1426 0aac F1FFFF1A 		bne	.L132
 1427 0ab0 0300A0E1 		mov	r0, r3
 1428              	.L131:
 1429              		.loc 1 1933 0
 1430 0ab4 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1431 0ab8 1EFF2FE1 		bx	lr
 1432              	.LFE30:
 1434              		.global	__aeabi_idiv
 1435              		.align	2
 1437              	fat16_write_dir_entry:
 1438              	.LFB24:
 1439              		.loc 1 1468 0
 1440              		@ Function supports interworking.
 1441              		@ args = 0, pretend = 0, frame = 56
 1442              		@ frame_needed = 0, uses_anonymous_args = 0
 1443              	.LVL154:
 1444 0abc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1445              	.LCFI13:
 1446              		.loc 1 1470 0
 1447 0ac0 000050E3 		cmp	r0, #0
 1448 0ac4 00005113 		cmpne	r1, #0
 1449              		.loc 1 1468 0
 1450 0ac8 3CD04DE2 		sub	sp, sp, #60
 1451              	.LCFI14:
 1452              		.loc 1 1470 0
 1453 0acc 0140A0E1 		mov	r4, r1
 1454 0ad0 A000000A 		beq	.L137
 1455              	.LVL155:
 1456              		.loc 1 1473 0
 1457 0ad4 003090E5 		ldr	r3, [r0, #0]
 1458              		.loc 1 1475 0
 1459 0ad8 0100A0E1 		mov	r0, r1
 1460              	.LVL156:
 1461              		.loc 1 1473 0
 1462 0adc 089093E5 		ldr	r9, [r3, #8]
 1463              	.LVL157:
 1464              		.loc 1 1475 0
 1465 0ae0 FEFFFFEB 		bl	strlen
 1466 0ae4 FF5000E2 		and	r5, r0, #255
 1467              	.LVL158:
 1468              		.loc 1 1476 0
 1469 0ae8 0D10A0E3 		mov	r1, #13
 1470 0aec 0C0085E2 		add	r0, r5, #12
 1471 0af0 FEFFFFEB 		bl	__aeabi_idiv
 1472              		.loc 1 1482 0
 1473 0af4 18608DE2 		add	r6, sp, #24
 1474              		.loc 1 1476 0
 1475 0af8 00A0A0E1 		mov	sl, r0
 1476              		.loc 1 1482 0
 1477 0afc 2010A0E3 		mov	r1, #32
 1478 0b00 0B20A0E3 		mov	r2, #11
 1479 0b04 0600A0E1 		mov	r0, r6
 1480              		.loc 1 1474 0
 1481 0b08 288094E5 		ldr	r8, [r4, #40]
 1482              	.LVL159:
 1483              		.loc 1 1482 0
 1484 0b0c FEFFFFEB 		bl	memset
 1485              		.loc 1 1483 0
 1486 0b10 0400A0E1 		mov	r0, r4
 1487 0b14 2E10A0E3 		mov	r1, #46
 1488 0b18 FEFFFFEB 		bl	strrchr
 1489              		.loc 1 1484 0
 1490 0b1c 000050E3 		cmp	r0, #0
 1491              		.loc 1 1476 0
 1492 0b20 FFA00AE2 		and	sl, sl, #255
 1493              	.LVL160:
 1494              		.loc 1 1484 0
 1495 0b24 0B00000A 		beq	.L138
 1496              	.LBB40:
 1497              		.loc 1 1486 0
 1498 0b28 017080E2 		add	r7, r0, #1
 1499              	.LVL161:
 1500              		.loc 1 1488 0
 1501 0b2c 0700A0E1 		mov	r0, r7
 1502 0b30 FEFFFFEB 		bl	strlen
 1503 0b34 FF2000E2 		and	r2, r0, #255
 1504              	.LVL162:
 1505              		.loc 1 1489 0
 1506 0b38 0230E0E1 		mvn	r3, r2
 1507 0b3c 035085E0 		add	r5, r5, r3
 1508              	.LVL163:
 1509              		.loc 1 1494 0
 1510 0b40 030052E3 		cmp	r2, #3
 1511 0b44 0320A023 		movcs	r2, #3
 1512              	.LVL164:
 1513 0b48 080086E2 		add	r0, r6, #8
 1514 0b4c 0710A0E1 		mov	r1, r7
 1515              		.loc 1 1489 0
 1516 0b50 FF5005E2 		and	r5, r5, #255
 1517              	.LVL165:
 1518              		.loc 1 1494 0
 1519 0b54 FEFFFFEB 		bl	memcpy
 1520              	.L138:
 1521              	.LBE40:
 1522              		.loc 1 1497 0
 1523 0b58 080055E3 		cmp	r5, #8
 1524 0b5c 18308DE2 		add	r3, sp, #24
 1525 0b60 0400008A 		bhi	.L139
 1526              		.loc 1 1499 0
 1527 0b64 0300A0E1 		mov	r0, r3
 1528 0b68 0520A0E1 		mov	r2, r5
 1529 0b6c 0410A0E1 		mov	r1, r4
 1530 0b70 FEFFFFEB 		bl	memcpy
 1531 0b74 0C0000EA 		b	.L140
 1532              	.L139:
 1533              	.LBB41:
 1534              		.loc 1 1503 0
 1535 0b78 030094E8 		ldmia	r4, {r0, r1}
 1536 0b7c 030083E8 		stmia	r3, {r0, r1}
 1537              		.loc 1 1508 0
 1538 0b80 2230D4E5 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 1539              	.LVL166:
 1540              		.loc 1 1510 0
 1541 0b84 9F0053E3 		cmp	r3, #159
 1542 0b88 2322A0E1 		mov	r2, r3, lsr #4
 1543              		.loc 1 1511 0
 1544 0b8c 0F3003E2 		and	r3, r3, #15
 1545              	.LVL167:
 1546              		.loc 1 1510 0
 1547 0b90 30208292 		addls	r2, r2, #48
 1548 0b94 61208282 		addhi	r2, r2, #97
 1549              		.loc 1 1512 0
 1550 0b98 090053E3 		cmp	r3, #9
 1551 0b9c 30308392 		addls	r3, r3, #48
 1552              	.LVL168:
 1553 0ba0 61308382 		addhi	r3, r3, #97
 1554              	.LVL169:
 1555              		.loc 1 1510 0
 1556 0ba4 1E20CDE5 		strb	r2, [sp, #30]
 1557              		.loc 1 1512 0
 1558 0ba8 1F30CDE5 		strb	r3, [sp, #31]
 1559              	.L140:
 1560              	.LBE41:
 1561              		.loc 1 1516 0
 1562 0bac 18508DE2 		add	r5, sp, #24
 1563              	.LVL170:
 1564 0bb0 0010A0E3 		mov	r1, #0
 1565 0bb4 1520A0E3 		mov	r2, #21
 1566 0bb8 0B0085E2 		add	r0, r5, #11
 1567 0bbc FEFFFFEB 		bl	memset
 1568              		.loc 1 1517 0
 1569 0bc0 2030D4E5 		ldrb	r3, [r4, #32]	@ zero_extendqisi2
 1570 0bc4 2330CDE5 		strb	r3, [sp, #35]
 1571              		.loc 1 1572 0
 1572 0bc8 B232D4E1 		ldrh	r3, [r4, #34]
 1573              		.loc 1 1573 0
 1574 0bcc 2324A0E1 		mov	r2, r3, lsr #8
 1575 0bd0 3320CDE5 		strb	r2, [sp, #51]
 1576              		.loc 1 1572 0
 1577 0bd4 3230CDE5 		strb	r3, [sp, #50]
 1578              		.loc 1 1574 0
 1579 0bd8 243094E5 		ldr	r3, [r4, #36]
 1580              		.loc 1 1577 0
 1581 0bdc 232CA0E1 		mov	r2, r3, lsr #24
 1582              		.loc 1 1575 0
 1583 0be0 2304A0E1 		mov	r0, r3, lsr #8
 1584              		.loc 1 1576 0
 1585 0be4 2318A0E1 		mov	r1, r3, lsr #16
 1586              		.loc 1 1575 0
 1587 0be8 3500CDE5 		strb	r0, [sp, #53]
 1588              		.loc 1 1576 0
 1589 0bec 3610CDE5 		strb	r1, [sp, #54]
 1590              		.loc 1 1577 0
 1591 0bf0 3720CDE5 		strb	r2, [sp, #55]
 1592              		.loc 1 1574 0
 1593 0bf4 3430CDE5 		strb	r3, [sp, #52]
 1594              		.loc 1 1580 0
 1595 0bf8 8A0288E0 		add	r0, r8, sl, asl #5
 1596 0bfc 0510A0E1 		mov	r1, r5
 1597 0c00 2020A0E3 		mov	r2, #32
 1598 0c04 0FE0A0E1 		mov	lr, pc
 1599 0c08 19FF2FE1 		bx	r9
 1600 0c0c 000050E3 		cmp	r0, #0
 1601 0c10 5000000A 		beq	.L137
 1602              		.loc 1 1584 0
 1603 0c14 1870DDE5 		ldrb	r7, [sp, #24]	@ zero_extendqisi2
 1604              	.LVL171:
 1605              		.loc 1 1467 0
 1606 0c18 0A3085E2 		add	r3, r5, #10
 1607              	.L145:
 1608              		.loc 1 1587 0
 1609 0c1c 0120F5E5 		ldrb	r2, [r5, #1]!	@ zero_extendqisi2
 1610 0c20 A710A0E1 		mov	r1, r7, lsr #1
 1611 0c24 877381E1 		orr	r7, r1, r7, asl #7
 1612              	.LVL172:
 1613 0c28 027087E0 		add	r7, r7, r2
 1614              		.loc 1 1586 0
 1615 0c2c 030055E1 		cmp	r5, r3
 1616              		.loc 1 1587 0
 1617 0c30 FF7007E2 		and	r7, r7, #255
 1618              	.LVL173:
 1619              		.loc 1 1586 0
 1620 0c34 F8FFFF1A 		bne	.L145
 1621              	.LBB42:
 1622              		.loc 1 1593 0
 1623 0c38 18608DE2 		add	r6, sp, #24
 1624              		.loc 1 1594 0
 1625 0c3c 012086E2 		add	r2, r6, #1
 1626              		.loc 1 1595 0
 1627 0c40 0E3086E2 		add	r3, r6, #14
 1628              		.loc 1 1596 0
 1629 0c44 1CC086E2 		add	ip, r6, #28
 1630              	.LBE42:
 1631              		.loc 1 1586 0
 1632 0c48 0A50A0E1 		mov	r5, sl
 1633              	.LVL174:
 1634              	.LBB43:
 1635              		.loc 1 1594 0
 1636 0c4c 0C208DE5 		str	r2, [sp, #12]
 1637              		.loc 1 1595 0
 1638 0c50 10308DE5 		str	r3, [sp, #16]
 1639              		.loc 1 1596 0
 1640 0c54 14C08DE5 		str	ip, [sp, #20]
 1641 0c58 3A0000EA 		b	.L146
 1642              	.L153:
 1643              		.loc 1 1593 0
 1644 0c5c 0010A0E3 		mov	r1, #0
 1645 0c60 2020A0E3 		mov	r2, #32
 1646 0c64 0600A0E1 		mov	r0, r6
 1647 0c68 FEFFFFEB 		bl	memset
 1648              		.loc 1 1594 0
 1649 0c6c FF10A0E3 		mov	r1, #255
 1650 0c70 0A20A0E3 		mov	r2, #10
 1651 0c74 0C009DE5 		ldr	r0, [sp, #12]
 1652 0c78 FEFFFFEB 		bl	memset
 1653              		.loc 1 1595 0
 1654 0c7c FF10A0E3 		mov	r1, #255
 1655 0c80 0C20A0E3 		mov	r2, #12
 1656 0c84 10009DE5 		ldr	r0, [sp, #16]
 1657 0c88 FEFFFFEB 		bl	memset
 1658              		.loc 1 1603 0
 1659 0c8c 011045E2 		sub	r1, r5, #1
 1660 0c90 0DC0A0E3 		mov	ip, #13
 1661 0c94 9C4121E0 		mla	r1, ip, r1, r4
 1662              	.LVL175:
 1663              		.loc 1 1596 0
 1664 0c98 14209DE5 		ldr	r2, [sp, #20]
 1665 0c9c 0030E0E3 		mvn	r3, #0
 1666              		.loc 1 1599 0
 1667 0ca0 0A0055E1 		cmp	r5, sl
 1668              		.loc 1 1596 0
 1669 0ca4 003082E5 		str	r3, [r2, #0]
 1670              		.loc 1 1608 0
 1671 0ca8 04408DE5 		str	r4, [sp, #4]
 1672              		.loc 1 1600 0
 1673 0cac 40308503 		orreq	r3, r5, #64
 1674              		.loc 1 1598 0
 1675 0cb0 1850CDE5 		strb	r5, [sp, #24]
 1676              		.loc 1 1603 0
 1677 0cb4 0020A0E3 		mov	r2, #0
 1678              		.loc 1 1600 0
 1679 0cb8 1830CD05 		streqb	r3, [sp, #24]
 1680              		.loc 1 1603 0
 1681 0cbc 0130A0E3 		mov	r3, #1
 1682              	.LVL176:
 1683              	.L152:
 1684              		.loc 1 1607 0
 1685 0cc0 010083E2 		add	r0, r3, #1
 1686 0cc4 FF0000E2 		and	r0, r0, #255
 1687              	.LVL177:
 1688              		.loc 1 1608 0
 1689 0cc8 01B080E2 		add	fp, r0, #1
 1690              		.loc 1 1607 0
 1691 0ccc 02E0D1E7 		ldrb	lr, [r1, r2]	@ zero_extendqisi2
 1692 0cd0 38408DE2 		add	r4, sp, #56
 1693              	.LVL178:
 1694 0cd4 03C084E0 		add	ip, r4, r3
 1695              		.loc 1 1608 0
 1696 0cd8 FF300BE2 		and	r3, fp, #255
 1697              	.LVL179:
 1698              		.loc 1 1607 0
 1699 0cdc 20E04CE5 		strb	lr, [ip, #-32]
 1700              		.loc 1 1610 0
 1701 0ce0 0B0053E3 		cmp	r3, #11
 1702              		.loc 1 1608 0
 1703 0ce4 000084E0 		add	r0, r4, r0
 1704 0ce8 00C0A0E3 		mov	ip, #0
 1705 0cec 20C040E5 		strb	ip, [r0, #-32]
 1706              		.loc 1 1610 0
 1707 0cf0 0E30A003 		moveq	r3, #14
 1708              	.LVL180:
 1709 0cf4 0100000A 		beq	.L148
 1710 0cf8 1A0053E3 		cmp	r3, #26
 1711 0cfc 1C30A003 		moveq	r3, #28
 1712              	.LVL181:
 1713              	.L148:
 1714              		.loc 1 1620 0
 1715 0d00 0200D1E7 		ldrb	r0, [r1, r2]	@ zero_extendqisi2
 1716 0d04 000050E3 		cmp	r0, #0
 1717 0d08 0200000A 		beq	.L151
 1718              		.loc 1 1605 0
 1719 0d0c 1E0053E3 		cmp	r3, #30
 1720              		.loc 1 1620 0
 1721 0d10 012082E2 		add	r2, r2, #1
 1722              		.loc 1 1605 0
 1723 0d14 E9FFFF9A 		bls	.L152
 1724              	.L151:
 1725              		.loc 1 1625 0
 1726 0d18 0F30A0E3 		mov	r3, #15
 1727              	.LVL182:
 1728              		.loc 1 1631 0
 1729 0d1c 0800A0E1 		mov	r0, r8
 1730              		.loc 1 1625 0
 1731 0d20 2330CDE5 		strb	r3, [sp, #35]
 1732              		.loc 1 1628 0
 1733 0d24 2570CDE5 		strb	r7, [sp, #37]
 1734              		.loc 1 1631 0
 1735 0d28 0610A0E1 		mov	r1, r6
 1736              	.LVL183:
 1737 0d2c 2020A0E3 		mov	r2, #32
 1738 0d30 04409DE5 		ldr	r4, [sp, #4]
 1739              	.LVL184:
 1740 0d34 0FE0A0E1 		mov	lr, pc
 1741 0d38 19FF2FE1 		bx	r9
 1742              	.LBE43:
 1743              		.loc 1 1591 0
 1744 0d3c 015045E2 		sub	r5, r5, #1
 1745              	.LVL185:
 1746              	.LBB44:
 1747              		.loc 1 1633 0
 1748 0d40 208088E2 		add	r8, r8, #32
 1749              	.LVL186:
 1750              	.LBE44:
 1751              		.loc 1 1591 0
 1752 0d44 FF5005E2 		and	r5, r5, #255
 1753              	.LVL187:
 1754              	.L146:
 1755 0d48 000055E3 		cmp	r5, #0
 1756 0d4c C2FFFF1A 		bne	.L153
 1757 0d50 0100A0E3 		mov	r0, #1
 1758 0d54 000000EA 		b	.L154
 1759              	.LVL188:
 1760              	.L137:
 1761 0d58 0000A0E3 		mov	r0, #0
 1762              	.LVL189:
 1763              	.L154:
 1764              		.loc 1 1641 0
 1765 0d5c 3CD08DE2 		add	sp, sp, #60
 1766 0d60 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1767 0d64 1EFF2FE1 		bx	lr
 1768              	.LFE24:
 1770              		.global	__aeabi_uidiv
 1771              		.align	2
 1772              		.global	fat16_create_file
 1774              	fat16_create_file:
 1775              	.LFB25:
 1776              		.loc 1 1670 0
 1777              		@ Function supports interworking.
 1778              		@ args = 0, pretend = 0, frame = 8
 1779              		@ frame_needed = 0, uses_anonymous_args = 0
 1780              	.LVL190:
 1781              		.loc 1 1672 0
 1782 0d68 000050E3 		cmp	r0, #0
 1783 0d6c 00005113 		cmpne	r1, #0
 1784              		.loc 1 1670 0
 1785 0d70 F74F2DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1786              	.LCFI15:
 1787              	.LVL191:
 1788              		.loc 1 1672 0
 1789 0d74 0150A0E1 		mov	r5, r1
 1790              	.LVL192:
 1791 0d78 0040A0E1 		mov	r4, r0
 1792              	.LVL193:
 1793              		.loc 1 1670 0
 1794 0d7c 0260A0E1 		mov	r6, r2
 1795              	.LVL194:
 1796              		.loc 1 1672 0
 1797 0d80 6200000A 		beq	.L159
 1798              	.LVL195:
 1799 0d84 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1800 0d88 000053E3 		cmp	r3, #0
 1801 0d8c 5F00000A 		beq	.L159
 1802              	.L172:
 1803              		.loc 1 1678 0
 1804 0d90 0610A0E1 		mov	r1, r6
 1805 0d94 0400A0E1 		mov	r0, r4
 1806 0d98 FEFFFFEB 		bl	fat16_read_dir
 1807 0d9c 008050E2 		subs	r8, r0, #0
 1808              		.loc 1 1681 0
 1809 0da0 0610A0E1 		mov	r1, r6
 1810 0da4 0500A0E1 		mov	r0, r5
 1811              		.loc 1 1678 0
 1812 0da8 0500000A 		beq	.L160
 1813              		.loc 1 1681 0
 1814 0dac FEFFFFEB 		bl	strcmp
 1815 0db0 000050E3 		cmp	r0, #0
 1816 0db4 F5FFFF1A 		bne	.L172
 1817              	.LBB45:
 1818              	.LBB46:
 1819              		.loc 1 1435 0
 1820 0db8 B003C4E1 		strh	r0, [r4, #48]	@ movhi
 1821 0dbc 0100A0E3 		mov	r0, #1
 1822 0dc0 530000EA 		b	.L162
 1823              	.L160:
 1824              	.LBE46:
 1825              	.LBE45:
 1826              		.loc 1 1688 0
 1827 0dc4 0810A0E1 		mov	r1, r8
 1828 0dc8 2C20A0E3 		mov	r2, #44
 1829 0dcc 0600A0E1 		mov	r0, r6
 1830 0dd0 FEFFFFEB 		bl	memset
 1831              		.loc 1 1689 0
 1832 0dd4 0510A0E1 		mov	r1, r5
 1833 0dd8 1F20A0E3 		mov	r2, #31
 1834 0ddc 0600A0E1 		mov	r0, r6
 1835 0de0 FEFFFFEB 		bl	strncpy
 1836              		.loc 1 1692 0
 1837 0de4 0500A0E1 		mov	r0, r5
 1838 0de8 FEFFFFEB 		bl	strlen
 1839 0dec 0D10A0E3 		mov	r1, #13
 1840 0df0 FEFFFFEB 		bl	__aeabi_uidiv
 1841              		.loc 1 1695 0
 1842 0df4 B672D4E1 		ldrh	r7, [r4, #38]
 1843              	.LVL196:
 1844              		.loc 1 1694 0
 1845 0df8 005094E5 		ldr	r5, [r4, #0]
 1846              	.LVL197:
 1847              		.loc 1 1700 0
 1848 0dfc 000057E3 		cmp	r7, #0
 1849              		.loc 1 1703 0
 1850 0e00 14409505 		ldreq	r4, [r5, #20]
 1851              	.LVL198:
 1852              		.loc 1 1692 0
 1853 0e04 020080E2 		add	r0, r0, #2
 1854              		.loc 1 1704 0
 1855 0e08 18809505 		ldreq	r8, [r5, #24]
 1856              	.LVL199:
 1857              		.loc 1 1692 0
 1858 0e0c FFB000E2 		and	fp, r0, #255
 1859              	.LVL200:
 1860              		.loc 1 1700 0
 1861 0e10 0840A011 		movne	r4, r8
 1862 0e14 0890A011 		movne	r9, r8
 1863              	.LVL201:
 1864              		.loc 1 1704 0
 1865 0e18 0490A001 		moveq	r9, r4
 1866 0e1c 00A0A0E3 		mov	sl, #0
 1867              	.LVL202:
 1868              	.LVL203:
 1869              	.L174:
 1870              	.LBB47:
 1871              		.loc 1 1710 0
 1872 0e20 080054E1 		cmp	r4, r8
 1873 0e24 1B00001A 		bne	.L165
 1874              		.loc 1 1712 0
 1875 0e28 000057E3 		cmp	r7, #0
 1876 0e2c 3700000A 		beq	.L159
 1877              		.loc 1 1718 0
 1878 0e30 000054E3 		cmp	r4, #0
 1879 0e34 1000000A 		beq	.L166
 1880              	.LBB48:
 1881              		.loc 1 1724 0
 1882 0e38 0500A0E1 		mov	r0, r5
 1883 0e3c 0710A0E1 		mov	r1, r7
 1884 0e40 F6FCFFEB 		bl	fat16_get_next_cluster
 1885              		.loc 1 1725 0
 1886 0e44 000050E3 		cmp	r0, #0
 1887 0e48 0A00001A 		bne	.L167
 1888              		.loc 1 1727 0
 1889 0e4c 0710A0E1 		mov	r1, r7
 1890 0e50 0500A0E1 		mov	r0, r5
 1891 0e54 0120A0E3 		mov	r2, #1
 1892 0e58 43FDFFEB 		bl	fat16_append_clusters
 1893              		.loc 1 1728 0
 1894 0e5c 000050E3 		cmp	r0, #0
 1895 0e60 2A00000A 		beq	.L159
 1896              		.loc 1 1732 0
 1897 0e64 B291D5E1 		ldrh	r9, [r5, #18]
 1898              	.LVL204:
 1899 0e68 183095E5 		ldr	r3, [r5, #24]
 1900 0e6c 020040E2 		sub	r0, r0, #2
 1901 0e70 903929E0 		mla	r9, r0, r9, r3
 1902              	.LVL205:
 1903              		.loc 1 1738 0
 1904 0e74 1E0000EA 		b	.L168
 1905              	.L167:
 1906 0e78 0070A0E1 		mov	r7, r0
 1907              	.LVL206:
 1908              	.L166:
 1909              	.LBE48:
 1910              		.loc 1 1744 0
 1911 0e7c B281D5E1 		ldrh	r8, [r5, #18]
 1912              	.LVL207:
 1913              		.loc 1 1743 0
 1914 0e80 183095E5 		ldr	r3, [r5, #24]
 1915 0e84 024047E2 		sub	r4, r7, #2
 1916              	.LVL208:
 1917 0e88 983424E0 		mla	r4, r8, r4, r3
 1918              	.LVL209:
 1919              		.loc 1 1745 0
 1920 0e8c 00A0A0E3 		mov	sl, #0
 1921              	.LVL210:
 1922 0e90 088084E0 		add	r8, r4, r8
 1923              	.LVL211:
 1924 0e94 0490A0E1 		mov	r9, r4
 1925              	.L165:
 1926              		.loc 1 1752 0
 1927 0e98 003095E5 		ldr	r3, [r5, #0]
 1928 0e9c 0400A0E1 		mov	r0, r4
 1929 0ea0 07108DE2 		add	r1, sp, #7
 1930 0ea4 0120A0E3 		mov	r2, #1
 1931 0ea8 00C093E5 		ldr	ip, [r3, #0]
 1932 0eac 0FE0A0E1 		mov	lr, pc
 1933 0eb0 1CFF2FE1 		bx	ip
 1934 0eb4 000050E3 		cmp	r0, #0
 1935 0eb8 1400000A 		beq	.L159
 1936              		.loc 1 1756 0
 1937 0ebc 0730DDE5 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1938 0ec0 E50053E3 		cmp	r3, #229
 1939 0ec4 00005313 		cmpne	r3, #0
 1940 0ec8 0030A013 		movne	r3, #0
 1941 0ecc 0130A003 		moveq	r3, #1
 1942              		.loc 1 1767 0
 1943 0ed0 20408412 		addne	r4, r4, #32
 1944 0ed4 03A0A011 		movne	sl, r3
 1945 0ed8 0490A011 		movne	r9, r4
 1946              		.loc 1 1756 0
 1947 0edc CFFFFF1A 		bne	.L174
 1948              		.loc 1 1759 0
 1949 0ee0 01A08AE2 		add	sl, sl, #1
 1950              	.LVL212:
 1951 0ee4 FFA00AE2 		and	sl, sl, #255
 1952              	.LVL213:
 1953              		.loc 1 1760 0
 1954 0ee8 0B005AE1 		cmp	sl, fp
 1955              		.loc 1 1763 0
 1956 0eec 20408432 		addcc	r4, r4, #32
 1957 0ef0 CAFFFF3A 		bcc	.L174
 1958              	.L168:
 1959              	.LBE47:
 1960              		.loc 1 1774 0
 1961 0ef4 289086E5 		str	r9, [r6, #40]
 1962              		.loc 1 1775 0
 1963 0ef8 0500A0E1 		mov	r0, r5
 1964 0efc 0610A0E1 		mov	r1, r6
 1965 0f00 EDFEFFEB 		bl	fat16_write_dir_entry
 1966 0f04 000050E2 		subs	r0, r0, #0
 1967 0f08 0100A013 		movne	r0, #1
 1968 0f0c 000000EA 		b	.L162
 1969              	.LVL214:
 1970              	.L159:
 1971 0f10 0000A0E3 		mov	r0, #0
 1972              	.LVL215:
 1973              	.L162:
 1974              		.loc 1 1783 0
 1975 0f14 FE4FBDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1976 0f18 1EFF2FE1 		bx	lr
 1977              	.LFE25:
 1979              		.align	2
 1980              		.global	fat16_resize_file
 1982              	fat16_resize_file:
 1983              	.LFB18:
 1984              		.loc 1 1254 0
 1985              		@ Function supports interworking.
 1986              		@ args = 0, pretend = 0, frame = 8
 1987              		@ frame_needed = 0, uses_anonymous_args = 0
 1988              	.LVL216:
 1989 0f1c F3472DE9 		stmfd	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 1990              	.LCFI16:
 1991              	.LVL217:
 1992              		.loc 1 1256 0
 1993 0f20 004050E2 		subs	r4, r0, #0
 1994              	.LVL218:
 1995              		.loc 1 1254 0
 1996 0f24 0170A0E1 		mov	r7, r1
 1997              	.LVL219:
 1998              		.loc 1 1256 0
 1999 0f28 5C00000A 		beq	.L176
 2000              	.LVL220:
 2001              		.loc 1 1260 0
 2002 0f2c 003094E5 		ldr	r3, [r4, #0]
 2003              		.loc 1 1259 0
 2004 0f30 B652D4E1 		ldrh	r5, [r4, #38]
 2005              	.LVL221:
 2006              		.loc 1 1260 0
 2007 0f34 B281D3E1 		ldrh	r8, [r3, #18]
 2008              	.LVL222:
 2009              		.loc 1 1265 0
 2010 0f38 019071E2 		rsbs	r9, r1, #1
 2011 0f3c 0090A033 		movcc	r9, #0
 2012 0f40 000055E3 		cmp	r5, #0
 2013 0f44 00005103 		cmpeq	r1, #0
 2014 0f48 0160A011 		movne	r6, r1
 2015              	.LVL223:
 2016              	.LBB49:
 2017              		.loc 1 1274 0
 2018 0f4c 00A06812 		rsbne	sl, r8, #0
 2019              	.LBE49:
 2020              		.loc 1 1265 0
 2021 0f50 0600001A 		bne	.L178
 2022              	.LVL224:
 2023 0f54 4A0000EA 		b	.L177
 2024              	.LVL225:
 2025              	.L180:
 2026              	.LBB50:
 2027              		.loc 1 1273 0
 2028 0f58 000094E5 		ldr	r0, [r4, #0]
 2029 0f5c AFFCFFEB 		bl	fat16_get_next_cluster
 2030              		.loc 1 1274 0
 2031 0f60 000050E3 		cmp	r0, #0
 2032 0f64 0400000A 		beq	.L179
 2033 0f68 0A6086E0 		add	r6, r6, sl
 2034 0f6c 0050A0E1 		mov	r5, r0
 2035              	.LVL226:
 2036              	.L178:
 2037              	.LBE50:
 2038              		.loc 1 1270 0
 2039 0f70 080056E1 		cmp	r6, r8
 2040              	.LBB51:
 2041              		.loc 1 1273 0
 2042 0f74 0510A0E1 		mov	r1, r5
 2043              	.LBE51:
 2044              		.loc 1 1270 0
 2045 0f78 F6FFFF8A 		bhi	.L180
 2046              	.L179:
 2047              		.loc 1 1285 0
 2048 0f7c 01A075E2 		rsbs	sl, r5, #1
 2049 0f80 00A0A033 		movcc	sl, #0
 2050 0f84 080056E1 		cmp	r6, r8
 2051 0f88 0A30A091 		movls	r3, sl
 2052 0f8c 01308A83 		orrhi	r3, sl, #1
 2053 0f90 000053E3 		cmp	r3, #0
 2054 0f94 1100000A 		beq	.L181
 2055              	.LBB52:
 2056              		.loc 1 1290 0
 2057 0f98 0810A0E1 		mov	r1, r8
 2058 0f9c 0600A0E1 		mov	r0, r6
 2059 0fa0 FEFFFFEB 		bl	__aeabi_uidiv
 2060 0fa4 0028A0E1 		mov	r2, r0, asl #16
 2061 0fa8 2228A0E1 		mov	r2, r2, lsr #16
 2062              	.LVL227:
 2063              		.loc 1 1291 0
 2064 0fac 980203E0 		mul	r3, r8, r2
 2065 0fb0 060053E1 		cmp	r3, r6
 2066              		.loc 1 1292 0
 2067 0fb4 01208232 		addcc	r2, r2, #1
 2068              	.LVL228:
 2069 0fb8 0228A031 		movcc	r2, r2, asl #16
 2070 0fbc 2228A031 		movcc	r2, r2, lsr #16
 2071              	.LVL229:
 2072              		.loc 1 1293 0
 2073 0fc0 000094E5 		ldr	r0, [r4, #0]
 2074 0fc4 0510A0E1 		mov	r1, r5
 2075 0fc8 E7FCFFEB 		bl	fat16_append_clusters
 2076              	.LVL230:
 2077              		.loc 1 1294 0
 2078 0fcc 000050E3 		cmp	r0, #0
 2079 0fd0 3200000A 		beq	.L176
 2080              		.loc 1 1297 0
 2081 0fd4 00005AE3 		cmp	sl, #0
 2082              		.loc 1 1300 0
 2083 0fd8 B602C411 		strneh	r0, [r4, #38]	@ movhi
 2084 0fdc 0050A011 		movne	r5, r0
 2085              	.LVL231:
 2086              	.L181:
 2087              	.LBE52:
 2088              		.loc 1 1306 0
 2089 0fe0 000059E3 		cmp	r9, #0
 2090              		.loc 1 1307 0
 2091 0fe4 0030A013 		movne	r3, #0	@ movhi
 2092 0fe8 B632C411 		strneh	r3, [r4, #38]	@ movhi
 2093              		.loc 1 1305 0
 2094 0fec 287084E5 		str	r7, [r4, #40]
 2095              		.loc 1 1308 0
 2096 0ff0 000094E5 		ldr	r0, [r4, #0]
 2097 0ff4 041084E2 		add	r1, r4, #4
 2098 0ff8 AFFEFFEB 		bl	fat16_write_dir_entry
 2099 0ffc 000050E3 		cmp	r0, #0
 2100 1000 2600000A 		beq	.L176
 2101              		.loc 1 1311 0
 2102 1004 000059E3 		cmp	r9, #0
 2103              		.loc 1 1314 0
 2104 1008 0510A011 		movne	r1, r5
 2105 100c 00009415 		ldrne	r0, [r4, #0]
 2106              		.loc 1 1311 0
 2107 1010 1A00001A 		bne	.L188
 2108              		.loc 1 1316 0
 2109 1014 080056E1 		cmp	r6, r8
 2110 1018 1900008A 		bhi	.L177
 2111              		.loc 1 1319 0
 2112 101c 006094E5 		ldr	r6, [r4, #0]
 2113              	.LVL232:
 2114              	.LBB53:
 2115              	.LBB54:
 2116              		.loc 1 887 0
 2117 1020 000056E3 		cmp	r6, #0
 2118 1024 01005513 		cmpne	r5, #1
 2119 1028 1500009A 		bls	.L177
 2120              		.loc 1 891 0
 2121 102c 0510A0E1 		mov	r1, r5
 2122 1030 0600A0E1 		mov	r0, r6
 2123 1034 79FCFFEB 		bl	fat16_get_next_cluster
 2124              		.loc 1 895 0
 2125 1038 0030E0E3 		mvn	r3, #0
 2126              		.loc 1 896 0
 2127 103c 0530CDE5 		strb	r3, [sp, #5]
 2128              		.loc 1 895 0
 2129 1040 0430CDE5 		strb	r3, [sp, #4]
 2130              		.loc 1 891 0
 2131 1044 0080A0E1 		mov	r8, r0
 2132              	.LVL233:
 2133              		.loc 1 897 0
 2134 1048 080096E5 		ldr	r0, [r6, #8]
 2135 104c 003096E5 		ldr	r3, [r6, #0]
 2136 1050 850080E0 		add	r0, r0, r5, asl #1
 2137 1054 04108DE2 		add	r1, sp, #4
 2138 1058 0220A0E3 		mov	r2, #2
 2139 105c 08C093E5 		ldr	ip, [r3, #8]
 2140 1060 0FE0A0E1 		mov	lr, pc
 2141 1064 1CFF2FE1 		bx	ip
 2142 1068 000050E3 		cmp	r0, #0
 2143 106c 0400000A 		beq	.L177
 2144              		.loc 1 901 0
 2145 1070 000058E3 		cmp	r8, #0
 2146 1074 0200000A 		beq	.L177
 2147              		.loc 1 902 0
 2148 1078 0600A0E1 		mov	r0, r6
 2149 107c 0810A0E1 		mov	r1, r8
 2150              	.LVL234:
 2151              	.L188:
 2152 1080 89FCFFEB 		bl	fat16_free_clusters
 2153              	.LVL235:
 2154              	.L177:
 2155              	.LBE54:
 2156              	.LBE53:
 2157              		.loc 1 1326 0
 2158 1084 303094E5 		ldr	r3, [r4, #48]
 2159 1088 030057E1 		cmp	r7, r3
 2160              		.loc 1 1329 0
 2161 108c 0030A033 		movcc	r3, #0	@ movhi
 2162              		.loc 1 1328 0
 2163 1090 30708435 		strcc	r7, [r4, #48]
 2164              		.loc 1 1329 0
 2165 1094 B433C431 		strcch	r3, [r4, #52]	@ movhi
 2166 1098 0100A0E3 		mov	r0, #1
 2167 109c 000000EA 		b	.L186
 2168              	.LVL236:
 2169              	.L176:
 2170 10a0 0000A0E3 		mov	r0, #0
 2171              	.L186:
 2172              		.loc 1 1336 0
 2173 10a4 FC47BDE8 		ldmfd	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 2174 10a8 1EFF2FE1 		bx	lr
 2175              	.LFE18:
 2177              		.align	2
 2178              		.global	fat16_seek_file
 2180              	fat16_seek_file:
 2181              	.LFB17:
 2182              		.loc 1 1204 0
 2183              		@ Function supports interworking.
 2184              		@ args = 0, pretend = 0, frame = 0
 2185              		@ frame_needed = 0, uses_anonymous_args = 0
 2186              	.LVL237:
 2187              		.loc 1 1205 0
 2188 10ac 000050E3 		cmp	r0, #0
 2189 10b0 00005113 		cmpne	r1, #0
 2190              		.loc 1 1204 0
 2191 10b4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2192              	.LCFI17:
 2193              		.loc 1 1205 0
 2194 10b8 0150A0E1 		mov	r5, r1
 2195 10bc 0040A0E1 		mov	r4, r0
 2196 10c0 1A00000A 		beq	.L191
 2197              	.LVL238:
 2198              		.loc 1 1209 0
 2199 10c4 010052E3 		cmp	r2, #1
 2200              		.loc 1 1208 0
 2201 10c8 306090E5 		ldr	r6, [r0, #48]
 2202              	.LVL239:
 2203              		.loc 1 1209 0
 2204 10cc 0400000A 		beq	.L193
 2205              	.LVL240:
 2206              		.loc 1 1212 0
 2207 10d0 00609135 		ldrcc	r6, [r1, #0]
 2208              	.LVL241:
 2209              		.loc 1 1209 0
 2210 10d4 0700003A 		bcc	.L195
 2211              	.LVL242:
 2212 10d8 020052E3 		cmp	r2, #2
 2213 10dc 1300001A 		bne	.L191
 2214 10e0 010000EA 		b	.L201
 2215              	.LVL243:
 2216              	.L193:
 2217              		.loc 1 1215 0
 2218 10e4 003091E5 		ldr	r3, [r1, #0]
 2219 10e8 010000EA 		b	.L199
 2220              	.LVL244:
 2221              	.L201:
 2222              		.loc 1 1218 0
 2223 10ec 006091E5 		ldr	r6, [r1, #0]
 2224              	.LVL245:
 2225 10f0 283090E5 		ldr	r3, [r0, #40]
 2226              	.LVL246:
 2227              	.L199:
 2228 10f4 036086E0 		add	r6, r6, r3
 2229              	.LVL247:
 2230              	.L195:
 2231              		.loc 1 1224 0
 2232 10f8 283094E5 		ldr	r3, [r4, #40]
 2233 10fc 030056E1 		cmp	r6, r3
 2234 1100 0400009A 		bls	.L196
 2235              	.LVL248:
 2236 1104 0400A0E1 		mov	r0, r4
 2237 1108 0610A0E1 		mov	r1, r6
 2238              	.LVL249:
 2239 110c FEFFFFEB 		bl	fat16_resize_file
 2240              	.LVL250:
 2241 1110 000050E3 		cmp	r0, #0
 2242 1114 0500000A 		beq	.L191
 2243              	.LVL251:
 2244              	.L196:
 2245              		.loc 1 1228 0
 2246 1118 0030A0E3 		mov	r3, #0	@ movhi
 2247              		.loc 1 1227 0
 2248 111c 306084E5 		str	r6, [r4, #48]
 2249              		.loc 1 1228 0
 2250 1120 B433C4E1 		strh	r3, [r4, #52]	@ movhi
 2251              		.loc 1 1230 0
 2252 1124 006085E5 		str	r6, [r5, #0]
 2253 1128 0100A0E3 		mov	r0, #1
 2254              		.loc 1 1231 0
 2255 112c 000000EA 		b	.L197
 2256              	.LVL252:
 2257              	.L191:
 2258 1130 0000A0E3 		mov	r0, #0
 2259              	.L197:
 2260              		.loc 1 1232 0
 2261 1134 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2262 1138 1EFF2FE1 		bx	lr
 2263              	.LFE17:
 2265              		.align	2
 2266              		.global	fat16_write_file
 2268              	fat16_write_file:
 2269              	.LFB16:
 2270              		.loc 1 1058 0
 2271              		@ Function supports interworking.
 2272              		@ args = 0, pretend = 0, frame = 8
 2273              		@ frame_needed = 0, uses_anonymous_args = 0
 2274              	.LVL253:
 2275 113c F74F2DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2276              	.LCFI18:
 2277              	.LVL254:
 2278              		.loc 1 1061 0
 2279 1140 000050E3 		cmp	r0, #0
 2280 1144 00005113 		cmpne	r1, #0
 2281              	.LVL255:
 2282 1148 0190A0E1 		mov	r9, r1
 2283 114c 0040A0E1 		mov	r4, r0
 2284              		.loc 1 1058 0
 2285 1150 04208DE5 		str	r2, [sp, #4]
 2286              	.LVL256:
 2287              		.loc 1 1061 0
 2288 1154 7400000A 		beq	.L203
 2289              	.LVL257:
 2290 1158 000052E3 		cmp	r2, #0
 2291 115c 7200000A 		beq	.L203
 2292              		.loc 1 1063 0
 2293 1160 308090E5 		ldr	r8, [r0, #48]
 2294 1164 283090E5 		ldr	r3, [r0, #40]
 2295 1168 030058E1 		cmp	r8, r3
 2296 116c 6E00008A 		bhi	.L203
 2297              	.LVL258:
 2298              		.loc 1 1067 0
 2299 1170 B453D0E1 		ldrh	r5, [r0, #52]
 2300              	.LVL259:
 2301              		.loc 1 1066 0
 2302 1174 000090E5 		ldr	r0, [r0, #0]
 2303              	.LVL260:
 2304              		.loc 1 1072 0
 2305 1178 000055E3 		cmp	r5, #0
 2306              		.loc 1 1066 0
 2307 117c B271D0E1 		ldrh	r7, [r0, #18]
 2308              	.LVL261:
 2309              		.loc 1 1072 0
 2310 1180 2000001A 		bne	.L204
 2311              		.loc 1 1074 0
 2312 1184 B652D4E1 		ldrh	r5, [r4, #38]
 2313              	.LVL262:
 2314              		.loc 1 1076 0
 2315 1188 000055E3 		cmp	r5, #0
 2316 118c 0800001A 		bne	.L205
 2317              		.loc 1 1078 0
 2318 1190 000058E3 		cmp	r8, #0
 2319 1194 6400001A 		bne	.L203
 2320              		.loc 1 1081 0
 2321 1198 0810A0E1 		mov	r1, r8
 2322 119c 0120A0E3 		mov	r2, #1
 2323              	.LVL263:
 2324 11a0 71FCFFEB 		bl	fat16_append_clusters
 2325              		.loc 1 1082 0
 2326 11a4 000050E3 		cmp	r0, #0
 2327              		.loc 1 1081 0
 2328 11a8 0050A0E1 		mov	r5, r0
 2329              	.LVL264:
 2330 11ac B602C4E1 		strh	r0, [r4, #38]	@ movhi
 2331              		.loc 1 1082 0
 2332 11b0 5D00000A 		beq	.L203
 2333              	.LVL265:
 2334              	.L205:
 2335              		.loc 1 1091 0
 2336 11b4 306094E5 		ldr	r6, [r4, #48]
 2337              	.LVL266:
 2338 11b8 000056E3 		cmp	r6, #0
 2339              		.loc 1 1057 0
 2340 11bc 00B06712 		rsbne	fp, r7, #0
 2341 11c0 06A06710 		rsbne	sl, r7, r6
 2342              		.loc 1 1091 0
 2343 11c4 0C00001A 		bne	.L206
 2344 11c8 0E0000EA 		b	.L204
 2345              	.LVL267:
 2346              	.L208:
 2347              	.LBB55:
 2348              		.loc 1 1098 0
 2349 11cc 000094E5 		ldr	r0, [r4, #0]
 2350              	.LVL268:
 2351 11d0 12FCFFEB 		bl	fat16_get_next_cluster
 2352              	.LVL269:
 2353              		.loc 1 1099 0
 2354 11d4 000050E3 		cmp	r0, #0
 2355 11d8 00005A03 		cmpeq	sl, #0
 2356              	.LVL270:
 2357              	.LBE55:
 2358              		.loc 1 1057 0
 2359 11dc 0B6086E0 		add	r6, r6, fp
 2360              	.LBB56:
 2361              		.loc 1 1099 0
 2362              		.loc 1 1101 0
 2363 11e0 0510A001 		moveq	r1, r5
 2364 11e4 00009405 		ldreq	r0, [r4, #0]
 2365              	.LVL271:
 2366 11e8 0120A003 		moveq	r2, #1
 2367 11ec 5EFCFF0B 		bleq	fat16_append_clusters
 2368              	.LVL272:
 2369              	.L207:
 2370              		.loc 1 1102 0
 2371 11f0 005050E2 		subs	r5, r0, #0
 2372              	.LVL273:
 2373              		.loc 1 1101 0
 2374 11f4 0BA08AE0 		add	sl, sl, fp
 2375              		.loc 1 1102 0
 2376 11f8 4B00000A 		beq	.L203
 2377              	.LVL274:
 2378              	.L206:
 2379              		.loc 1 1095 0
 2380 11fc 070056E1 		cmp	r6, r7
 2381              		.loc 1 1098 0
 2382 1200 0510A0E1 		mov	r1, r5
 2383              		.loc 1 1095 0
 2384 1204 F0FFFF2A 		bcs	.L208
 2385              	.LVL275:
 2386              	.L204:
 2387              	.LBE56:
 2388              		.loc 1 1069 0
 2389 1208 0800A0E1 		mov	r0, r8
 2390              	.LVL276:
 2391 120c 0710A0E1 		mov	r1, r7
 2392 1210 FEFFFFEB 		bl	__aeabi_uidivmod
 2393              	.LVL277:
 2394 1214 04609DE5 		ldr	r6, [sp, #4]
 2395              	.LVL278:
 2396 1218 0118A0E1 		mov	r1, r1, asl #16
 2397 121c 21A8A0E1 		mov	sl, r1, lsr #16
 2398              	.LVL279:
 2399              	.L213:
 2400              	.LBB57:
 2401              		.loc 1 1114 0
 2402 1220 003094E5 		ldr	r3, [r4, #0]
 2403              		.loc 1 1116 0
 2404 1224 07806AE0 		rsb	r8, sl, r7
 2405              	.LVL280:
 2406              		.loc 1 1121 0
 2407 1228 182093E5 		ldr	r2, [r3, #24]
 2408              		.loc 1 1116 0
 2409 122c 0888A0E1 		mov	r8, r8, asl #16
 2410 1230 2888A0E1 		mov	r8, r8, lsr #16
 2411              	.LVL281:
 2412 1234 060058E1 		cmp	r8, r6
 2413 1238 0680A021 		movcs	r8, r6
 2414              	.LVL282:
 2415              		.loc 1 1121 0
 2416 123c 02208AE0 		add	r2, sl, r2
 2417 1240 020045E2 		sub	r0, r5, #2
 2418              	.LVL283:
 2419 1244 972020E0 		mla	r0, r7, r0, r2
 2420 1248 003093E5 		ldr	r3, [r3, #0]
 2421 124c 0820A0E1 		mov	r2, r8
 2422 1250 0910A0E1 		mov	r1, r9
 2423 1254 08C093E5 		ldr	ip, [r3, #8]
 2424 1258 0FE0A0E1 		mov	lr, pc
 2425 125c 1CFF2FE1 		bx	ip
 2426              		.loc 1 1126 0
 2427 1260 062068E0 		rsb	r2, r8, r6
 2428              		.loc 1 1121 0
 2429 1264 000050E3 		cmp	r0, #0
 2430              		.loc 1 1129 0
 2431 1268 0A3088E0 		add	r3, r8, sl
 2432              		.loc 1 1126 0
 2433 126c 0228A0E1 		mov	r2, r2, asl #16
 2434              		.loc 1 1121 0
 2435 1270 1A00000A 		beq	.L209
 2436              		.loc 1 1127 0
 2437 1274 301094E5 		ldr	r1, [r4, #48]
 2438              		.loc 1 1129 0
 2439 1278 070053E1 		cmp	r3, r7
 2440              		.loc 1 1127 0
 2441 127c 083081E0 		add	r3, r1, r8
 2442 1280 303084E5 		str	r3, [r4, #48]
 2443              		.loc 1 1126 0
 2444 1284 2268A0E1 		mov	r6, r2, lsr #16
 2445              	.LVL284:
 2446              		.loc 1 1129 0
 2447 1288 100000BA 		blt	.L210
 2448              	.LBB58:
 2449              		.loc 1 1132 0
 2450 128c 0510A0E1 		mov	r1, r5
 2451 1290 000094E5 		ldr	r0, [r4, #0]
 2452 1294 E1FBFFEB 		bl	fat16_get_next_cluster
 2453              		.loc 1 1133 0
 2454 1298 013070E2 		rsbs	r3, r0, #1
 2455 129c 0030A033 		movcc	r3, #0
 2456              	.LVL285:
 2457 12a0 000056E3 		cmp	r6, #0
 2458 12a4 0030A003 		moveq	r3, #0
 2459 12a8 000053E3 		cmp	r3, #0
 2460              		.loc 1 1135 0
 2461 12ac 0510A011 		movne	r1, r5
 2462 12b0 00009415 		ldrne	r0, [r4, #0]
 2463              	.LVL286:
 2464 12b4 0120A013 		movne	r2, #1
 2465 12b8 2BFCFF1B 		blne	fat16_append_clusters
 2466              	.LVL287:
 2467              	.L211:
 2468              		.loc 1 1136 0
 2469 12bc 000050E3 		cmp	r0, #0
 2470              		.loc 1 1138 0
 2471 12c0 B403C401 		streqh	r0, [r4, #52]	@ movhi
 2472              		.loc 1 1139 0
 2473 12c4 0500000A 		beq	.L209
 2474              	.L212:
 2475 12c8 0050A0E1 		mov	r5, r0
 2476              	.LVL288:
 2477 12cc 00A0A0E3 		mov	sl, #0
 2478              	.LVL289:
 2479              	.L210:
 2480              	.LBE58:
 2481              	.LBE57:
 2482              		.loc 1 1149 0
 2483 12d0 000056E3 		cmp	r6, #0
 2484              	.LBB59:
 2485              		.loc 1 1146 0
 2486 12d4 B453C4E1 		strh	r5, [r4, #52]	@ movhi
 2487              	.LBE59:
 2488              		.loc 1 1149 0
 2489              	.LBB60:
 2490              		.loc 1 1125 0
 2491 12d8 08908910 		addne	r9, r9, r8
 2492 12dc CFFFFF1A 		bne	.L213
 2493              	.L209:
 2494              	.LBE60:
 2495              		.loc 1 1152 0
 2496 12e0 303094E5 		ldr	r3, [r4, #48]
 2497 12e4 285094E5 		ldr	r5, [r4, #40]
 2498              	.LVL290:
 2499 12e8 050053E1 		cmp	r3, r5
 2500 12ec 0900009A 		bls	.L214
 2501              	.LBB61:
 2502              		.loc 1 1157 0
 2503 12f0 283084E5 		str	r3, [r4, #40]
 2504              		.loc 1 1159 0
 2505 12f4 000094E5 		ldr	r0, [r4, #0]
 2506              	.LVL291:
 2507 12f8 041084E2 		add	r1, r4, #4
 2508 12fc EEFDFFEB 		bl	fat16_write_dir_entry
 2509 1300 000050E3 		cmp	r0, #0
 2510              		.loc 1 1165 0
 2511 1304 30609405 		ldreq	r6, [r4, #48]
 2512              	.LVL292:
 2513 1308 06606500 		rsbeq	r6, r5, r6
 2514 130c 0668A001 		moveq	r6, r6, asl #16
 2515              		.loc 1 1166 0
 2516 1310 30508405 		streq	r5, [r4, #48]
 2517              		.loc 1 1165 0
 2518 1314 2668A001 		moveq	r6, r6, lsr #16
 2519              	.LVL293:
 2520              	.L214:
 2521              	.LBE61:
 2522              		.loc 1 1170 0
 2523 1318 04309DE5 		ldr	r3, [sp, #4]
 2524 131c 036066E0 		rsb	r6, r6, r3
 2525              	.LVL294:
 2526 1320 0668A0E1 		mov	r6, r6, asl #16
 2527 1324 2668A0E1 		mov	r6, r6, lsr #16
 2528 1328 000000EA 		b	.L215
 2529              	.LVL295:
 2530              	.L203:
 2531 132c 0C609FE5 		ldr	r6, .L217
 2532              	.LVL296:
 2533              	.L215:
 2534 1330 0668A0E1 		mov	r6, r6, asl #16
 2535              		.loc 1 1175 0
 2536 1334 4608A0E1 		mov	r0, r6, asr #16
 2537              	.LVL297:
 2538 1338 FE4FBDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2539 133c 1EFF2FE1 		bx	lr
 2540              	.L218:
 2541              		.align	2
 2542              	.L217:
 2543 1340 FFFF0000 		.word	65535
 2544              	.LFE16:
 2546              		.align	2
 2547              		.global	fat16_close_dir
 2549              	fat16_close_dir:
 2550              	.LFB20:
 2551              		.loc 1 1375 0
 2552              		@ Function supports interworking.
 2553              		@ args = 0, pretend = 0, frame = 0
 2554              		@ frame_needed = 0, uses_anonymous_args = 0
 2555              	.LVL298:
 2556              		.loc 1 1376 0
 2557 1344 000050E3 		cmp	r0, #0
 2558              		.loc 1 1375 0
 2559 1348 10402DE9 		stmfd	sp!, {r4, lr}
 2560              	.LCFI19:
 2561              		.loc 1 1376 0
 2562              		.loc 1 1377 0
 2563 134c FEFFFF1B 		blne	free
 2564              	.LVL299:
 2565              	.L221:
 2566              		.loc 1 1378 0
 2567 1350 1040BDE8 		ldmfd	sp!, {r4, lr}
 2568 1354 1EFF2FE1 		bx	lr
 2569              	.LFE20:
 2571              		.align	2
 2572              		.global	fat16_close_file
 2574              	fat16_close_file:
 2575              	.LFB14:
 2576              		.loc 1 944 0
 2577              		@ Function supports interworking.
 2578              		@ args = 0, pretend = 0, frame = 0
 2579              		@ frame_needed = 0, uses_anonymous_args = 0
 2580              	.LVL300:
 2581              		.loc 1 945 0
 2582 1358 000050E3 		cmp	r0, #0
 2583              		.loc 1 944 0
 2584 135c 10402DE9 		stmfd	sp!, {r4, lr}
 2585              	.LCFI20:
 2586              		.loc 1 945 0
 2587              		.loc 1 946 0
 2588 1360 FEFFFF1B 		blne	free
 2589              	.LVL301:
 2590              	.L224:
 2591              		.loc 1 947 0
 2592 1364 1040BDE8 		ldmfd	sp!, {r4, lr}
 2593 1368 1EFF2FE1 		bx	lr
 2594              	.LFE14:
 2596              		.align	2
 2597              		.global	fat16_close
 2599              	fat16_close:
 2600              	.LFB1:
 2601              		.loc 1 243 0
 2602              		@ Function supports interworking.
 2603              		@ args = 0, pretend = 0, frame = 0
 2604              		@ frame_needed = 0, uses_anonymous_args = 0
 2605              	.LVL302:
 2606              		.loc 1 244 0
 2607 136c 000050E3 		cmp	r0, #0
 2608              		.loc 1 243 0
 2609 1370 10402DE9 		stmfd	sp!, {r4, lr}
 2610              	.LCFI21:
 2611              		.loc 1 244 0
 2612              		.loc 1 247 0
 2613 1374 FEFFFF1B 		blne	free
 2614              	.LVL303:
 2615              	.L227:
 2616              		.loc 1 248 0
 2617 1378 1040BDE8 		ldmfd	sp!, {r4, lr}
 2618 137c 1EFF2FE1 		bx	lr
 2619              	.LFE1:
 2621              		.align	2
 2622              		.global	fat16_open_dir
 2624              	fat16_open_dir:
 2625              	.LFB19:
 2626              		.loc 1 1348 0
 2627              		@ Function supports interworking.
 2628              		@ args = 0, pretend = 0, frame = 0
 2629              		@ frame_needed = 0, uses_anonymous_args = 0
 2630              	.LVL304:
 2631              		.loc 1 1349 0
 2632 1380 000050E3 		cmp	r0, #0
 2633 1384 00005113 		cmpne	r1, #0
 2634              		.loc 1 1348 0
 2635 1388 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2636              	.LCFI22:
 2637              		.loc 1 1349 0
 2638 138c 0140A0E1 		mov	r4, r1
 2639 1390 0070A0E1 		mov	r7, r0
 2640 1394 0080A013 		movne	r8, #0
 2641 1398 0180A003 		moveq	r8, #1
 2642 139c 1100000A 		beq	.L229
 2643              	.LVL305:
 2644 13a0 2030D1E5 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2645 13a4 100013E3 		tst	r3, #16
 2646 13a8 0E00000A 		beq	.L229
 2647              	.LVL306:
 2648              		.loc 1 1352 0
 2649 13ac 3400A0E3 		mov	r0, #52
 2650 13b0 FEFFFFEB 		bl	malloc
 2651              	.LVL307:
 2652              		.loc 1 1353 0
 2653 13b4 005050E2 		subs	r5, r0, #0
 2654              	.LVL308:
 2655 13b8 0B00000A 		beq	.L230
 2656              		.loc 1 1356 0
 2657 13bc 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 2658              	.LVL309:
 2659 13c0 046085E2 		add	r6, r5, #4
 2660 13c4 06C0A0E1 		mov	ip, r6
 2661 13c8 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 2662 13cc 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 2663 13d0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 2664 13d4 070094E8 		ldmia	r4, {r0, r1, r2}
 2665              		.loc 1 1357 0
 2666 13d8 007085E5 		str	r7, [r5, #0]
 2667              		.loc 1 1356 0
 2668 13dc 07008CE8 		stmia	ip, {r0, r1, r2}
 2669              		.loc 1 1358 0
 2670 13e0 B083C5E1 		strh	r8, [r5, #48]	@ movhi
 2671              		.loc 1 1360 0
 2672 13e4 000000EA 		b	.L230
 2673              	.LVL310:
 2674              	.L229:
 2675 13e8 0050A0E3 		mov	r5, #0
 2676              	.LVL311:
 2677              	.L230:
 2678              		.loc 1 1361 0
 2679 13ec 0500A0E1 		mov	r0, r5
 2680 13f0 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2681 13f4 1EFF2FE1 		bx	lr
 2682              	.LFE19:
 2684              		.align	2
 2685              		.global	fat16_open_file
 2687              	fat16_open_file:
 2688              	.LFB13:
 2689              		.loc 1 920 0
 2690              		@ Function supports interworking.
 2691              		@ args = 0, pretend = 0, frame = 0
 2692              		@ frame_needed = 0, uses_anonymous_args = 0
 2693              	.LVL312:
 2694              		.loc 1 921 0
 2695 13f8 000050E3 		cmp	r0, #0
 2696 13fc 00005113 		cmpne	r1, #0
 2697              		.loc 1 920 0
 2698 1400 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2699              	.LCFI23:
 2700              		.loc 1 921 0
 2701 1404 0140A0E1 		mov	r4, r1
 2702 1408 0080A0E1 		mov	r8, r0
 2703 140c 1400000A 		beq	.L233
 2704              	.LVL313:
 2705 1410 20A0D1E5 		ldrb	sl, [r1, #32]	@ zero_extendqisi2
 2706 1414 10A01AE2 		ands	sl, sl, #16
 2707 1418 1100001A 		bne	.L233
 2708              	.LVL314:
 2709              		.loc 1 924 0
 2710 141c 3800A0E3 		mov	r0, #56
 2711 1420 FEFFFFEB 		bl	malloc
 2712              	.LVL315:
 2713              		.loc 1 925 0
 2714 1424 005050E2 		subs	r5, r0, #0
 2715              	.LVL316:
 2716 1428 0E00000A 		beq	.L234
 2717              		.loc 1 928 0
 2718 142c 0470A0E1 		mov	r7, r4
 2719 1430 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 2720              	.LVL317:
 2721 1434 046085E2 		add	r6, r5, #4
 2722 1438 06C0A0E1 		mov	ip, r6
 2723 143c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 2724 1440 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 2725 1444 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 2726 1448 070097E8 		ldmia	r7, {r0, r1, r2}
 2727 144c 07008CE8 		stmia	ip, {r0, r1, r2}
 2728              		.loc 1 931 0
 2729 1450 B242D4E1 		ldrh	r4, [r4, #34]
 2730              		.loc 1 929 0
 2731 1454 008085E5 		str	r8, [r5, #0]
 2732              		.loc 1 930 0
 2733 1458 30A085E5 		str	sl, [r5, #48]
 2734              		.loc 1 931 0
 2735 145c B443C5E1 		strh	r4, [r5, #52]	@ movhi
 2736              		.loc 1 933 0
 2737 1460 000000EA 		b	.L234
 2738              	.LVL318:
 2739              	.L233:
 2740 1464 0050A0E3 		mov	r5, #0
 2741              	.LVL319:
 2742              	.L234:
 2743              		.loc 1 934 0
 2744 1468 0500A0E1 		mov	r0, r5
 2745 146c F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2746 1470 1EFF2FE1 		bx	lr
 2747              	.LFE13:
 2749              		.align	2
 2750              		.global	open_file_in_dir
 2752              	open_file_in_dir:
 2753              	.LFB31:
 2754              		.loc 1 1936 0
 2755              		@ Function supports interworking.
 2756              		@ args = 0, pretend = 0, frame = 48
 2757              		@ frame_needed = 0, uses_anonymous_args = 0
 2758              	.LVL320:
 2759 1474 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2760              	.LCFI24:
 2761 1478 34D04DE2 		sub	sp, sp, #52
 2762              	.LCFI25:
 2763              		.loc 1 1938 0
 2764 147c 04408DE2 		add	r4, sp, #4
 2765 1480 0430A0E1 		mov	r3, r4
 2766              		.loc 1 1936 0
 2767 1484 0050A0E1 		mov	r5, r0
 2768              		.loc 1 1938 0
 2769 1488 FEFFFFEB 		bl	find_file_in_dir
 2770              	.LVL321:
 2771 148c 000050E3 		cmp	r0, #0
 2772              		.loc 1 1941 0
 2773 1490 0500A011 		movne	r0, r5
 2774 1494 0410A011 		movne	r1, r4
 2775 1498 FEFFFF1B 		blne	fat16_open_file
 2776              	.L238:
 2777              		.loc 1 1942 0
 2778 149c 34D08DE2 		add	sp, sp, #52
 2779 14a0 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 2780 14a4 1EFF2FE1 		bx	lr
 2781              	.LFE31:
 2783              		.align	2
 2784              		.global	fat16_get_dir_entry_of_path
 2786              	fat16_get_dir_entry_of_path:
 2787              	.LFB8:
 2788              		.loc 1 624 0
 2789              		@ Function supports interworking.
 2790              		@ args = 0, pretend = 0, frame = 0
 2791              		@ frame_needed = 0, uses_anonymous_args = 0
 2792              	.LVL322:
 2793              		.loc 1 625 0
 2794 14a8 000050E3 		cmp	r0, #0
 2795 14ac 00005113 		cmpne	r1, #0
 2796              		.loc 1 624 0
 2797 14b0 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2798              	.LCFI26:
 2799              		.loc 1 625 0
 2800 14b4 0140A0E1 		mov	r4, r1
 2801 14b8 00A0A0E1 		mov	sl, r0
 2802              		.loc 1 624 0
 2803 14bc 0250A0E1 		mov	r5, r2
 2804              		.loc 1 625 0
 2805 14c0 3B00000A 		beq	.L241
 2806              	.LVL323:
 2807 14c4 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2808 14c8 000053E3 		cmp	r3, #0
 2809 14cc 00005213 		cmpne	r2, #0
 2810 14d0 3700000A 		beq	.L241
 2811              	.LVL324:
 2812              		.loc 1 628 0
 2813 14d4 2F0053E3 		cmp	r3, #47
 2814              		.loc 1 629 0
 2815 14d8 01408102 		addeq	r4, r1, #1
 2816              	.LVL325:
 2817              		.loc 1 632 0
 2818 14dc 0200A0E1 		mov	r0, r2
 2819 14e0 0010A0E3 		mov	r1, #0
 2820 14e4 2C20A0E3 		mov	r2, #44
 2821              	.LVL326:
 2822 14e8 FEFFFFEB 		bl	memset
 2823              		.loc 1 633 0
 2824 14ec 1030A0E3 		mov	r3, #16
 2825 14f0 2030C5E5 		strb	r3, [r5, #32]
 2826              		.loc 1 635 0
 2827 14f4 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 2828 14f8 000053E3 		cmp	r3, #0
 2829 14fc 2E00000A 		beq	.L243
 2830              	.LVL327:
 2831              	.L254:
 2832              	.LBB62:
 2833              		.loc 1 640 0
 2834 1500 0A00A0E1 		mov	r0, sl
 2835 1504 0510A0E1 		mov	r1, r5
 2836 1508 FEFFFFEB 		bl	fat16_open_dir
 2837              		.loc 1 641 0
 2838 150c 006050E2 		subs	r6, r0, #0
 2839 1510 2700000A 		beq	.L241
 2840              		.loc 1 645 0
 2841 1514 0400A0E1 		mov	r0, r4
 2842 1518 2F10A0E3 		mov	r1, #47
 2843 151c FEFFFFEB 		bl	strchr
 2844              		.loc 1 646 0
 2845 1520 007050E2 		subs	r7, r0, #0
 2846 1524 0200001A 		bne	.L244
 2847              		.loc 1 647 0
 2848 1528 0400A0E1 		mov	r0, r4
 2849 152c FEFFFFEB 		bl	strlen
 2850 1530 007084E0 		add	r7, r4, r0
 2851              	.L244:
 2852              		.loc 1 648 0
 2853 1534 078064E0 		rsb	r8, r4, r7
 2854              	.LVL328:
 2855 1538 FF8008E2 		and	r8, r8, #255
 2856              	.LVL329:
 2857              		.loc 1 651 0
 2858 153c 130000EA 		b	.L253
 2859              	.L247:
 2860              		.loc 1 654 0
 2861 1540 FEFFFFEB 		bl	strlen
 2862 1544 080050E1 		cmp	r0, r8
 2863 1548 1000001A 		bne	.L253
 2864              		.loc 1 655 0
 2865 154c 0400A0E1 		mov	r0, r4
 2866 1550 0510A0E1 		mov	r1, r5
 2867 1554 0820A0E1 		mov	r2, r8
 2868 1558 FEFFFFEB 		bl	strncmp
 2869              		.loc 1 654 0
 2870 155c 009050E2 		subs	r9, r0, #0
 2871 1560 0A00001A 		bne	.L253
 2872              		.loc 1 658 0
 2873 1564 0600A0E1 		mov	r0, r6
 2874 1568 FEFFFFEB 		bl	fat16_close_dir
 2875              		.loc 1 661 0
 2876 156c 0830D4E7 		ldrb	r3, [r4, r8]	@ zero_extendqisi2
 2877 1570 000053E3 		cmp	r3, #0
 2878 1574 1000000A 		beq	.L243
 2879              		.loc 1 665 0
 2880 1578 2030D5E5 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 2881 157c 100013E3 		tst	r3, #16
 2882 1580 0B00000A 		beq	.L241
 2883              		.loc 1 668 0
 2884 1584 014087E2 		add	r4, r7, #1
 2885 1588 0960A0E1 		mov	r6, r9
 2886              		.loc 1 669 0
 2887 158c 050000EA 		b	.L246
 2888              	.L253:
 2889              		.loc 1 651 0
 2890 1590 0510A0E1 		mov	r1, r5
 2891 1594 0600A0E1 		mov	r0, r6
 2892 1598 FEFFFFEB 		bl	fat16_read_dir
 2893 159c 000050E3 		cmp	r0, #0
 2894              		.loc 1 654 0
 2895 15a0 0500A0E1 		mov	r0, r5
 2896              		.loc 1 651 0
 2897 15a4 E5FFFF1A 		bne	.L247
 2898              	.L246:
 2899              		.loc 1 676 0
 2900 15a8 0600A0E1 		mov	r0, r6
 2901 15ac FEFFFFEB 		bl	fat16_close_dir
 2902              	.LBE62:
 2903              		.loc 1 677 0
 2904 15b0 D2FFFFEA 		b	.L254
 2905              	.LVL330:
 2906              	.L241:
 2907 15b4 0000A0E3 		mov	r0, #0
 2908 15b8 000000EA 		b	.L249
 2909              	.LVL331:
 2910              	.L243:
 2911 15bc 0100A0E3 		mov	r0, #1
 2912              	.LVL332:
 2913              	.L249:
 2914              		.loc 1 680 0
 2915 15c0 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2916 15c4 1EFF2FE1 		bx	lr
 2917              	.LFE8:
 2919              		.align	2
 2920              		.global	fat16_open
 2922              	fat16_open:
 2923              	.LFB0:
 2924              		.loc 1 203 0
 2925              		@ Function supports interworking.
 2926              		@ args = 0, pretend = 0, frame = 64
 2927              		@ frame_needed = 0, uses_anonymous_args = 0
 2928              	.LVL333:
 2929 15c8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2930              	.LCFI27:
 2931              		.loc 1 204 0
 2932 15cc 007050E2 		subs	r7, r0, #0
 2933              		.loc 1 203 0
 2934 15d0 44D04DE2 		sub	sp, sp, #68
 2935              	.LCFI28:
 2936              		.loc 1 204 0
 2937 15d4 6E00000A 		beq	.L256
 2938              	.LVL334:
 2939              		.loc 1 206 0
 2940 15d8 083097E5 		ldr	r3, [r7, #8]
 2941 15dc 000053E3 		cmp	r3, #0
 2942 15e0 6B00000A 		beq	.L256
 2943              		.loc 1 213 0
 2944 15e4 1C00A0E3 		mov	r0, #28
 2945 15e8 FEFFFFEB 		bl	malloc
 2946              		.loc 1 214 0
 2947 15ec 000050E3 		cmp	r0, #0
 2948              	.LVL335:
 2949              		.loc 1 213 0
 2950 15f0 0060A0E1 		mov	r6, r0
 2951              	.LVL336:
 2952 15f4 0040A0E1 		mov	r4, r0
 2953              		.loc 1 214 0
 2954 15f8 0200001A 		bne	.L257
 2955              	.LVL337:
 2956              		.loc 1 216 0
 2957 15fc A4019FE5 		ldr	r0, .L262
 2958              	.LVL338:
 2959 1600 FEFFFFEB 		bl	rprintf
 2960              		.loc 1 217 0
 2961 1604 630000EA 		b	.L258
 2962              	.LVL339:
 2963              	.L257:
 2964              		.loc 1 219 0
 2965 1608 0010A0E3 		mov	r1, #0
 2966 160c 1C20A0E3 		mov	r2, #28
 2967 1610 FEFFFFEB 		bl	memset
 2968              	.LVL340:
 2969              	.LBB65:
 2970              	.LBB66:
 2971              		.loc 1 271 0
 2972 1614 109097E5 		ldr	r9, [r7, #16]
 2973 1618 8994A0E1 		mov	r9, r9, asl #9
 2974              	.LVL341:
 2975              	.LBE66:
 2976              	.LBE65:
 2977              		.loc 1 221 0
 2978 161c 007086E5 		str	r7, [r6, #0]
 2979              	.LVL342:
 2980              	.LBB68:
 2981              	.LBB67:
 2982              		.loc 1 273 0
 2983 1620 0B0089E2 		add	r0, r9, #11
 2984 1624 24108DE2 		add	r1, sp, #36
 2985 1628 1920A0E3 		mov	r2, #25
 2986 162c 00C097E5 		ldr	ip, [r7, #0]
 2987 1630 0FE0A0E1 		mov	lr, pc
 2988 1634 1CFF2FE1 		bx	ip
 2989 1638 000050E3 		cmp	r0, #0
 2990 163c 5000000A 		beq	.L259
 2991              		.loc 1 287 0
 2992 1640 2F30DDE5 		ldrb	r3, [sp, #47]	@ zero_extendqisi2
 2993              		.loc 1 276 0
 2994 1644 2400DDE5 		ldrb	r0, [sp, #36]	@ zero_extendqisi2
 2995              		.loc 1 277 0
 2996 1648 2520DDE5 		ldrb	r2, [sp, #37]	@ zero_extendqisi2
 2997              		.loc 1 287 0
 2998 164c 30C0DDE5 		ldrb	ip, [sp, #48]	@ zero_extendqisi2
 2999              		.loc 1 276 0
 3000 1650 10008DE5 		str	r0, [sp, #16]
 3001              		.loc 1 293 0
 3002 1654 0CC493E1 		orrs	ip, r3, ip, asl #8
 3003              	.LVL343:
 3004              		.loc 1 279 0
 3005 1658 2700DDE5 		ldrb	r0, [sp, #39]	@ zero_extendqisi2
 3006              		.loc 1 278 0
 3007 165c 2630DDE5 		ldrb	r3, [sp, #38]	@ zero_extendqisi2
 3008              		.loc 1 277 0
 3009 1660 14208DE5 		str	r2, [sp, #20]
 3010              		.loc 1 280 0
 3011 1664 2820DDE5 		ldrb	r2, [sp, #40]	@ zero_extendqisi2
 3012              		.loc 1 278 0
 3013 1668 08308DE5 		str	r3, [sp, #8]
 3014              		.loc 1 279 0
 3015 166c 18008DE5 		str	r0, [sp, #24]
 3016              		.loc 1 280 0
 3017 1670 1C208DE5 		str	r2, [sp, #28]
 3018              		.loc 1 281 0
 3019 1674 29E0DDE5 		ldrb	lr, [sp, #41]	@ zero_extendqisi2
 3020              	.LVL344:
 3021              		.loc 1 282 0
 3022 1678 2A00DDE5 		ldrb	r0, [sp, #42]	@ zero_extendqisi2
 3023              		.loc 1 283 0
 3024 167c 2B50DDE5 		ldrb	r5, [sp, #43]	@ zero_extendqisi2
 3025              		.loc 1 284 0
 3026 1680 2C30DDE5 		ldrb	r3, [sp, #44]	@ zero_extendqisi2
 3027              		.loc 1 285 0
 3028 1684 2D20DDE5 		ldrb	r2, [sp, #45]	@ zero_extendqisi2
 3029              		.loc 1 288 0
 3030 1688 39A0DDE5 		ldrb	sl, [sp, #57]	@ zero_extendqisi2
 3031              		.loc 1 289 0
 3032 168c 3AB0DDE5 		ldrb	fp, [sp, #58]	@ zero_extendqisi2
 3033              		.loc 1 290 0
 3034 1690 3B80DDE5 		ldrb	r8, [sp, #59]	@ zero_extendqisi2
 3035              		.loc 1 291 0
 3036 1694 3C10DDE5 		ldrb	r1, [sp, #60]	@ zero_extendqisi2
 3037              		.loc 1 293 0
 3038 1698 3900000A 		beq	.L259
 3039              		.loc 1 291 0
 3040 169c 0888A0E1 		mov	r8, r8, asl #16
 3041 16a0 0B8488E1 		orr	r8, r8, fp, asl #8
 3042 16a4 0A8088E1 		orr	r8, r8, sl
 3043              		.loc 1 297 0
 3044 16a8 018C98E1 		orrs	r8, r8, r1, asl #24
 3045              	.LVL345:
 3046 16ac 0100001A 		bne	.L260
 3047              		.loc 1 299 0
 3048 16b0 028493E1 		orrs	r8, r3, r2, asl #8
 3049              	.LVL346:
 3050 16b4 3200000A 		beq	.L259
 3051              	.LVL347:
 3052              	.L260:
 3053              		.loc 1 283 0
 3054 16b8 055480E1 		orr	r5, r0, r5, asl #8
 3055              		.loc 1 311 0
 3056 16bc 1F00E0E3 		mvn	r0, #31
 3057 16c0 950000E0 		mul	r0, r5, r0
 3058              		.loc 1 310 0
 3059 16c4 9E0C0CE0 		mul	ip, lr, ip
 3060              	.LVL348:
 3061              		.loc 1 277 0
 3062 16c8 10309DE5 		ldr	r3, [sp, #16]
 3063 16cc 14209DE5 		ldr	r2, [sp, #20]
 3064              		.loc 1 283 0
 3065 16d0 0C508DE5 		str	r5, [sp, #12]
 3066              		.loc 1 277 0
 3067 16d4 025483E1 		orr	r5, r3, r2, asl #8
 3068              	.LVL349:
 3069              		.loc 1 311 0
 3070 16d8 000065E0 		rsb	r0, r5, r0
 3071              		.loc 1 309 0
 3072 16dc 18309DE5 		ldr	r3, [sp, #24]
 3073 16e0 1C209DE5 		ldr	r2, [sp, #28]
 3074              		.loc 1 311 0
 3075 16e4 0510A0E1 		mov	r1, r5
 3076 16e8 010080E2 		add	r0, r0, #1
 3077              		.loc 1 309 0
 3078 16ec 02A483E1 		orr	sl, r3, r2, asl #8
 3079              		.loc 1 311 0
 3080 16f0 00B06CE2 		rsb	fp, ip, #0
 3081              		.loc 1 310 0
 3082 16f4 04C08DE5 		str	ip, [sp, #4]
 3083              		.loc 1 311 0
 3084 16f8 FEFFFFEB 		bl	__aeabi_idiv
 3085              	.LVL350:
 3086 16fc 0BB06AE0 		rsb	fp, sl, fp
 3087 1700 00008BE0 		add	r0, fp, r0
 3088 1704 080080E0 		add	r0, r0, r8
 3089 1708 08109DE5 		ldr	r1, [sp, #8]
 3090 170c FEFFFFEB 		bl	__aeabi_uidiv
 3091              		.loc 1 312 0
 3092 1710 FF3E40E2 		sub	r3, r0, #4080
 3093 1714 053043E2 		sub	r3, r3, #5
 3094 1718 0F0A53E3 		cmp	r3, #61440
 3095              		.loc 1 311 0
 3096 171c 00B0A0E1 		mov	fp, r0
 3097              		.loc 1 312 0
 3098 1720 1700002A 		bcs	.L259
 3099              		.loc 1 325 0
 3100 1724 959A2AE0 		mla	sl, r5, sl, r9
 3101              		.loc 1 316 0
 3102 1728 0630A0E3 		mov	r3, #6
 3103 172c 0C30C7E5 		strb	r3, [r7, #12]
 3104              		.loc 1 320 0
 3105 1730 0010A0E3 		mov	r1, #0
 3106 1734 1820A0E3 		mov	r2, #24
 3107 1738 040084E2 		add	r0, r4, #4
 3108 173c FEFFFFEB 		bl	memset
 3109              		.loc 1 334 0
 3110 1740 04309DE5 		ldr	r3, [sp, #4]
 3111              		.loc 1 331 0
 3112 1744 08209DE5 		ldr	r2, [sp, #8]
 3113              		.loc 1 334 0
 3114 1748 95A323E0 		mla	r3, r5, r3, sl
 3115              		.loc 1 322 0
 3116 174c 950808E0 		mul	r8, r5, r8
 3117              	.LVL351:
 3118              		.loc 1 331 0
 3119 1750 950202E0 		mul	r2, r5, r2
 3120              		.loc 1 338 0
 3121 1754 0C009DE5 		ldr	r0, [sp, #12]
 3122              		.loc 1 328 0
 3123 1758 02B08BE2 		add	fp, fp, #2
 3124              		.loc 1 338 0
 3125 175c 801283E0 		add	r1, r3, r0, asl #5
 3126              		.loc 1 328 0
 3127 1760 8BB0A0E1 		mov	fp, fp, asl #1
 3128              		.loc 1 338 0
 3129 1764 181084E5 		str	r1, [r4, #24]
 3130              		.loc 1 322 0
 3131 1768 048084E5 		str	r8, [r4, #4]
 3132              		.loc 1 328 0
 3133 176c 0CB084E5 		str	fp, [r4, #12]
 3134              		.loc 1 331 0
 3135 1770 B221C4E1 		strh	r2, [r4, #18]	@ movhi
 3136              		.loc 1 324 0
 3137 1774 08A084E5 		str	sl, [r4, #8]
 3138              		.loc 1 330 0
 3139 1778 B051C4E1 		strh	r5, [r4, #16]	@ movhi
 3140              		.loc 1 333 0
 3141 177c 143084E5 		str	r3, [r4, #20]
 3142 1780 040000EA 		b	.L258
 3143              	.LVL352:
 3144              	.L259:
 3145              	.LBE67:
 3146              	.LBE68:
 3147              		.loc 1 224 0
 3148 1784 20009FE5 		ldr	r0, .L262+4
 3149 1788 FEFFFFEB 		bl	rprintf
 3150              	.LVL353:
 3151              		.loc 1 225 0
 3152 178c 0400A0E1 		mov	r0, r4
 3153 1790 FEFFFFEB 		bl	free
 3154              	.LVL354:
 3155              	.L256:
 3156              		.loc 1 226 0
 3157 1794 0060A0E3 		mov	r6, #0
 3158              	.LVL355:
 3159              	.L258:
 3160              		.loc 1 230 0
 3161 1798 0600A0E1 		mov	r0, r6
 3162 179c 44D08DE2 		add	sp, sp, #68
 3163 17a0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3164 17a4 1EFF2FE1 		bx	lr
 3165              	.L263:
 3166              		.align	2
 3167              	.L262:
 3168 17a8 00000000 		.word	.LC0
 3169 17ac 0F000000 		.word	.LC1
 3170              	.LFE0:
 3172              		.section	.rodata
 3173              		.align	2
 3174              		.set	.LANCHOR0,. + 0
 3177              	CSWTCH.22:
 3178 0000 00       		.byte	0
 3179 0001 01       		.byte	1
 3180 0002 00       		.byte	0
 3181 0003 00       		.section	.rodata.str1.1,"aMS",%progbits,1
 3182              	.LC0:
 3183 0000 4D414C4C 		.ascii	"MALLOC FAILS\012\015\000"
 3183      4F432046 
 3183      41494C53 
 3183      0A0D00
 3184              	.LC1:
 3185 000f 4661696C 		.ascii	"Failed Reading Header\012\015\000"
 3185      65642052 
 3185      65616469 
 3185      6E672048 
 3185      65616465 
 4007              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fat16.c
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:22     .text:0000000000000000 fat16_dir_entry_seek_callback
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:32     .text:0000000000000000 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:81     .text:0000000000000070 fat16_dir_entry_read_callback
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:279    .text:000000000000021c $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:284    .text:0000000000000220 fat16_get_next_cluster
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:292    .text:0000000000000220 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:350    .text:00000000000002a8 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:355    .text:00000000000002ac fat16_free_clusters
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:363    .text:00000000000002ac $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:450    .text:0000000000000368 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:455    .text:000000000000036c fat16_append_clusters
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:462    .text:000000000000036c $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:625    .text:00000000000004d8 fat16_read_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:847    .text:0000000000000670 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:853    .text:0000000000000674 fat16_reset_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:862    .text:0000000000000674 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:875    .text:0000000000000688 fat16_set_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:896    .text:0000000000000698 fat16_delete_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:980    .text:0000000000000740 fat16_get_fs_size
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1005   .text:0000000000000760 fat16_get_fs_free
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1096   .text:0000000000000808 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1103   .text:0000000000000814 fat16_get_fs_free_callback
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1111   .text:0000000000000814 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1152   .text:000000000000085c fat16_file_size
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1169   .text:0000000000000864 fat16_read_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1376   .text:0000000000000a5c $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1383   .text:0000000000000a64 find_file_in_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1390   .text:0000000000000a64 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1437   .text:0000000000000abc fat16_write_dir_entry
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1774   .text:0000000000000d68 fat16_create_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:1982   .text:0000000000000f1c fat16_resize_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2180   .text:00000000000010ac fat16_seek_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2268   .text:000000000000113c fat16_write_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2543   .text:0000000000001340 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2549   .text:0000000000001344 fat16_close_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2557   .text:0000000000001344 $a
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2574   .text:0000000000001358 fat16_close_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2599   .text:000000000000136c fat16_close
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2624   .text:0000000000001380 fat16_open_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2687   .text:00000000000013f8 fat16_open_file
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2752   .text:0000000000001474 open_file_in_dir
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2786   .text:00000000000014a8 fat16_get_dir_entry_of_path
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:2922   .text:00000000000015c8 fat16_open
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:3168   .text:00000000000017a8 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:3177   .rodata:0000000000000000 CSWTCH.22
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:3178   .rodata:0000000000000000 $d
/var/folders/c7/c7+1KegJECCEn2gM8K5Cj++++TI/-Tmp-//ccI4sRIX.s:3188   .debug_frame:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
memset
strcmp
__aeabi_idiv
strlen
strrchr
memcpy
__aeabi_uidiv
strncpy
free
malloc
strchr
strncmp
rprintf
